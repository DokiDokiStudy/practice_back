---
title: '3.5 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화'
categoryPath:
  - 'Docker'
  - '3장 도커 이미지 만들기'
  - '3.5 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화'
authorNick: '관리자'
createdAt: '2025-08-27'
updateMode: 'upsert'
---

# 3.5 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화

도커의 이미지 레이어는 순차적으로 쌓이게 되고, 중간에 레이어가 변경되면 변경된 레이어보다 위에 오는 레이어를 재사용할 수 없습니다.

```
docker image build -t web-ping:v2 .
...
=> CACHED [stage-1 2/6] WORKDIR /app
=> CACHED [stage-1 3/6] COPY --from=build /app/dist ./dist
=> CACHED [stage-1 4/6] COPY --from=build /app/node_modules ./node_modules
...
```

앞에서 설명했던대로 Dockerfile 스크립트의 인스트럭션은 하나의 이미지와 1:1 관계로 맺어지는데 이 인스트럭션의 결과가 같다면 이미지를 재사용합니다. 이런 방식으로 동일한 인스트럭션을 다시 실행하는 낭비를 줄일 수 있습니다.

**다만 변경된 레이어 이후에는 레이어를 재사용할 수 없기 때문에 새롭게 실행됩니다.**

## 레이어 캐시의 동작 원리

### 캐시 무효화의 연쇄 효과

레이어 캐시는 위에서부터 아래로 순차적으로 확인됩니다. 한 레이어가 변경되면 그 아래 모든 레이어가 다시 실행됩니다.

```dockerfile
FROM diamol/node          # Layer 1: 캐시 사용 가능
ENV TARGET="blog.sixeyed.com"  # Layer 2: 캐시 사용 가능
ENV METHOD="HEAD"         # Layer 3: 캐시 사용 가능
WORKDIR /web-ping         # Layer 4: 캐시 사용 가능
COPY app.js .            # Layer 5: 파일이 변경되면 캐시 무효화
CMD ["node", "app.js"]   # Layer 6: 위 레이어 변경으로 재실행
```

**캐시 동작 예시:**

```
app.js 파일 수정 후 재빌드:
✓ Layer 1-4: Using cache
✗ Layer 5-6: 새로 실행
```

### 실습: 캐시 동작 확인

```bash
# 첫 번째 빌드
docker build -t web-ping:v1 .

# app.js 파일 수정
echo "console.log('Updated!');" >> app.js

# 두 번째 빌드 - 캐시 동작 관찰
docker build -t web-ping:v2 .
```

**출력에서 확인할 수 있는 것:**

- `=> CACHED`: 캐시된 레이어 사용
- `=> [stage-1 5/6] COPY app.js .`: 새로 실행되는 레이어

## Dockerfile 스크립트 개선

web-ping 이미지의 Dockerfile 스크립트에도 개선할 점이 있습니다.

### 개선 전 (비효율적)

```dockerfile
FROM diamol/node
ENV TARGET="blog.sixeyed.com"
ENV METHOD="HEAD"
ENV INTERVAL="3000"
WORKDIR /web-ping
COPY app.js .
CMD ["node", "/web-ping/app.js"]
```

### 개선 후 (효율적)

```dockerfile
FROM diamol/node

# CMD 인스트럭션을 초반부로 이동 (거의 변경되지 않음)
CMD ["node", "/web-ping/app.js"]

# ENV 인스트럭션을 "\"로 결합하여 레이어 수 최소화
ENV TARGET="blog.sixeyed.com" \
    METHOD="HEAD" \
    INTERVAL="3000"

WORKDIR /web-ping

# 자주 변경되는 파일은 마지막에 배치
COPY app.js .
```

**개선 효과:**

- ENV 레이어 3개 → 1개로 통합
- CMD는 거의 변경되지 않으므로 캐시 활용 극대화
- app.js 변경 시에도 대부분의 레이어를 재사용

## 최적화 전략

### 1. 변경 빈도에 따른 레이어 순서

```dockerfile
# 변경 빈도: 낮음 → 높음 순서로 배치

FROM node:18                    # 거의 변경 안됨
CMD ["npm", "start"]           # 거의 변경 안됨
ENV NODE_ENV=production        # 가끔 변경됨
WORKDIR /app                   # 가끔 변경됨
COPY package*.json ./          # 의존성 변경 시에만
RUN npm install                # package.json 변경 시에만 재실행
COPY . .                      # 소스 코드 변경 시마다 재실행
```

### 2. RUN 명령어 결합

```dockerfile
# 비효율적 (3개 레이어)
RUN apt-get update
RUN apt-get install -y curl
RUN rm -rf /var/lib/apt/lists/*

# 효율적 (1개 레이어)
RUN apt-get update && \
    apt-get install -y curl && \
    rm -rf /var/lib/apt/lists/*
```

### 3. 의존성 파일 우선 복사

```dockerfile
# Node.js 프로젝트 최적화 예시
FROM node:18
WORKDIR /app

# 의존성 파일만 먼저 복사
COPY package*.json ./
RUN npm install              # package.json 변경 시에만 재실행

# 소스 코드는 나중에 복사
COPY . .                    # 소스 변경 시에만 재실행
CMD ["npm", "start"]
```

## 실습: 캐시 최적화 비교

### 비효율적인 Dockerfile

```dockerfile
# Dockerfile.inefficient
FROM node:18
WORKDIR /app

# 모든 파일을 먼저 복사 (비효율적)
COPY . .
RUN npm install
CMD ["npm", "start"]
```

### 최적화된 Dockerfile

```dockerfile
# Dockerfile.optimized
FROM node:18
WORKDIR /app

# 의존성 파일만 먼저 복사
COPY package*.json ./
RUN npm install

# 소스 코드는 나중에 복사
COPY . .
CMD ["npm", "start"]
```

### 성능 비교 실험

```bash
# 프로젝트 준비
mkdir cache-optimization-test
cd cache-optimization-test

# package.json 생성
cat > package.json << EOF
{
  "name": "cache-test",
  "dependencies": {
    "express": "^4.18.2"
  }
}
EOF

# 소스 파일 생성
echo "console.log('Hello World');" > app.js

# 첫 번째 빌드 (비효율적)
echo "=== 비효율적 버전 첫 빌드 ==="
time docker build -f Dockerfile.inefficient -t cache-test-bad .

# 소스 수정
echo "console.log('Hello World Updated!');" > app.js

# 재빌드 (비효율적)
echo "=== 비효율적 버전 재빌드 ==="
time docker build -f Dockerfile.inefficient -t cache-test-bad .

# 소스 원복
echo "console.log('Hello World');" > app.js

# 첫 번째 빌드 (최적화)
echo "=== 최적화 버전 첫 빌드 ==="
time docker build -f Dockerfile.optimized -t cache-test-good .

# 소스 수정
echo "console.log('Hello World Updated!');" > app.js

# 재빌드 (최적화)
echo "=== 최적화 버전 재빌드 ==="
time docker build -f Dockerfile.optimized -t cache-test-good .
```

**예상 결과:**

- 비효율적 버전: 소스 변경 시 npm install까지 재실행
- 최적화 버전: 소스 변경 시 npm install은 캐시 사용

## .dockerignore로 빌드 최적화

### .dockerignore 파일 활용

불필요한 파일을 빌드 컨텍스트에서 제외하여 캐시 효율성을 높입니다.

```bash
# .dockerignore
node_modules/
npm-debug.log
.git/
.env
README.md
*.log
.tmp/
coverage/
```

### 효과 확인

```bash
# .dockerignore 없이 빌드
rm .dockerignore 2>/dev/null || true
echo "=== .dockerignore 없이 ==="
time docker build -t no-ignore .

# .dockerignore 있이 빌드
cat > .dockerignore << EOF
node_modules/
.git/
*.log
EOF

echo "=== .dockerignore 있이 ==="
time docker build -t with-ignore .
```

## 주요 태그와 용어 정리

### 캐시 관련 명령어

| 명령어                    | 설명                    | 예시                        |
| ------------------------- | ----------------------- | --------------------------- |
| `docker build --no-cache` | 캐시 없이 전체 재빌드   | `docker build --no-cache .` |
| `docker system prune`     | 사용하지 않는 캐시 정리 | `docker system prune -f`    |
| `docker builder prune`    | 빌드 캐시만 정리        | `docker builder prune`      |

### 주요 용어

- **레이어 캐시**: 이전 빌드의 레이어를 재사용하는 메커니즘
- **캐시 무효화**: 레이어 변경으로 인한 캐시 사용 불가 상태
- **빌드 컨텍스트**: `docker build` 시 도커 데몬으로 전송되는 파일들
- **연쇄 재빌드**: 한 레이어 변경으로 인한 하위 레이어들의 재실행

## 연습 문제

**문제 1:** 다음 Dockerfile에서 app.js 파일을 수정했을 때 몇 개의 레이어가 다시 실행될까요?

```dockerfile
FROM node:18          # Layer 1
WORKDIR /app          # Layer 2
COPY package.json ./  # Layer 3
RUN npm install       # Layer 4
COPY app.js ./        # Layer 5 (변경됨)
CMD ["node", "app.js"] # Layer 6
```

<details>
<summary><strong>정답 보기</strong></summary>

**2개 레이어**가 다시 실행됩니다.

- Layer 5 (COPY app.js): 파일이 변경되어 재실행
- Layer 6 (CMD): Layer 5 변경으로 인한 연쇄 재실행

Layer 1-4는 캐시를 사용합니다.

</details>

<br/>

**문제 2:** 다음 중 캐시 효율성을 높이는 방법은?

A) 자주 변경되는 파일을 Dockerfile 상단에 배치  
B) 의존성 파일을 소스 코드보다 먼저 복사  
C) 모든 RUN 명령을 따로 작성  
D) .dockerignore 파일 사용하지 않기

<details>
<summary><strong>정답 보기</strong></summary>

**B) 의존성 파일을 소스 코드보다 먼저 복사**

이유:

- 의존성은 자주 변경되지 않으므로 캐시 활용도가 높음
- 소스 코드 변경 시에도 의존성 설치 단계를 재사용 가능
- A는 반대 (자주 변경되는 것은 아래쪽)
- C는 레이어 수만 증가
- D는 불필요한 파일도 포함하여 비효율적

</details>

<br/>

**문제 3:** ENV 명령어 3개를 하나로 합치는 올바른 방법은?

<details>
<summary><strong>정답 보기</strong></summary>

```dockerfile
# 개선 전 (3개 레이어)
ENV TARGET="blog.sixeyed.com"
ENV METHOD="HEAD"
ENV INTERVAL="3000"

# 개선 후 (1개 레이어)
ENV TARGET="blog.sixeyed.com" \
    METHOD="HEAD" \
    INTERVAL="3000"
```

백슬래시(`\`)를 사용하여 여러 환경변수를 한 번에 설정할 수 있습니다.

</details>
