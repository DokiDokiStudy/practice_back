---
title: "3.4 도커 이미지와 이미지 레이어 이해하기"
categoryPath:
  - "Docker"
  - "3장 도커 이미지 만들기"
  - "3.4 도커 이미지와 이미지 레이어 이해하기"
authorNick: "관리자"
createdAt: "2025-08-27"
updateMode: "upsert"
---
Docker 이미지의 레이어 시스템을 이해하는 것은 효율적인 이미지 최적화와 빌드 성능 향상의 핵심입니다. 이번 섹션에서는 레이어가 어떻게 작동하는지 실습을 통해 알아보겠습니다.

## 이미지 레이어의 기본 개념

### 레이어란 무엇인가?
- **Docker 이미지는 여러 레이어의 집합**입니다
- **각 Dockerfile 명령어가 새로운 레이어를 생성**합니다
- **변경이 없으면 캐시된 레이어를 재사용**합니다
- **읽기 전용 레이어들이 스택처럼 쌓여서 하나의 이미지가 됩니다**

### 레이어 구조 시각화
```
┌─────────────────────────────────────┐
│     컨테이너 레이어 (읽기/쓰기)     │  ← 실행 시 생성
├─────────────────────────────────────┤
│       CMD ["npm", "start"]          │  ← Dockerfile 마지막 명령
├─────────────────────────────────────┤  
│       COPY . .                      │  ← 애플리케이션 코드
├─────────────────────────────────────┤
│       RUN npm install               │  ← 의존성 설치
├─────────────────────────────────────┤
│       COPY package*.json ./         │  ← 패키지 파일
├─────────────────────────────────────┤
│       WORKDIR /app                  │  ← 작업 디렉토리 설정
├─────────────────────────────────────┤
│       FROM node:18-alpine           │  ← 베이스 이미지
└─────────────────────────────────────┘
```

## 실습: 레이어 생성 과정 관찰하기

### 1. 단계별 Dockerfile 작성
```bash
mkdir layer-example
cd layer-example

# 간단한 Dockerfile 작성
cat > Dockerfile << EOF
# 레이어 1: 베이스 이미지
FROM alpine:3.19

# 레이어 2: 패키지 설치
RUN apk add --no-cache curl

# 레이어 3: 디렉토리 생성
RUN mkdir /app

# 레이어 4: 작업 디렉토리 설정
WORKDIR /app

# 레이어 5: 파일 생성
RUN echo "Hello Docker Layers!" > hello.txt

# 레이어 6: 실행 권한 부여
RUN chmod +x hello.txt

# 레이어 7: 기본 명령어 설정
CMD ["cat", "hello.txt"]
EOF
```

### 2. 이미지 빌드 및 레이어 분석
```bash
# 이미지 빌드 (각 단계별 레이어 생성 확인)
docker build -t layer-example .

# 이미지 히스토리로 레이어 확인
docker history layer-example

# 출력 예시:
# IMAGE          CREATED          CREATED BY                                      SIZE
# abc123def456   2 minutes ago    CMD ["cat" "hello.txt"]                        0B
# bcd234eff567   2 minutes ago    RUN /bin/sh -c chmod +x hello.txt               0B  
# cde345f67890   2 minutes ago    RUN /bin/sh -c echo "Hello Docker Layers!"...  21B
# def456789abc   2 minutes ago    WORKDIR /app                                    0B
# efg567890bcd   2 minutes ago    RUN /bin/sh -c mkdir /app                       0B
# fgh678901cde   2 minutes ago    RUN /bin/sh -c apk add --no-cache curl         4.7MB
# 7e01a0d8a400   3 weeks ago      /bin/sh -c #(nop)  CMD ["/bin/sh"]             0B
```

### 3. 레이어별 크기 상세 분석
```bash
# 이미지 상세 정보로 레이어 ID 확인
docker inspect layer-example

# 각 레이어의 실제 내용 확인
docker history --no-trunc layer-example
```

## 레이어 캐싱 메커니즘 이해하기

### 캐시 동작 실습

#### 1. 첫 번째 빌드 (모든 레이어 새로 생성)
```bash
# 현재 시간 기록
date

# 빌드 시간 측정
time docker build -t cache-test:v1 .

# 빌드 로그에서 "Step X/Y :" 메시지들 확인
# 모든 단계가 새로 실행됨
```

#### 2. 두 번째 빌드 (캐시 사용)
```bash
# 동일한 Dockerfile로 다시 빌드
time docker build -t cache-test:v2 .

# 빌드 로그에서 "Using cache" 메시지 확인
# Step 1/7 : FROM alpine:3.19
#  ---> Using cache
# Step 2/7 : RUN apk add --no-cache curl  
#  ---> Using cache
# ... (모든 단계가 캐시 사용)
```

#### 3. 파일 변경 후 빌드 (부분 캐시 무효화)
```bash
# Dockerfile 수정 (마지막 레이어만 변경)
cat > Dockerfile << EOF
FROM alpine:3.19
RUN apk add --no-cache curl
RUN mkdir /app
WORKDIR /app
RUN echo "Hello Docker Layers!" > hello.txt
RUN chmod +x hello.txt
CMD ["echo", "Modified command!"]  # 이 부분만 변경
EOF

# 다시 빌드
time docker build -t cache-test:v3 .

# 마지막 단계만 새로 실행되고 나머지는 캐시 사용 확인
```

## 레이어 최적화 전략

### 1. RUN 명령어 결합으로 레이어 수 최소화

#### 비효율적인 방법 (여러 레이어)
```dockerfile
FROM alpine:3.19
RUN apk update
RUN apk add curl
RUN apk add wget  
RUN apk add vim
RUN rm -rf /var/cache/apk/*
# 총 5개의 레이어 생성
```

#### 효율적인 방법 (단일 레이어)
```dockerfile  
FROM alpine:3.19
RUN apk update && \
    apk add --no-cache \
        curl \
        wget \
        vim && \
    rm -rf /var/cache/apk/*
# 총 1개의 레이어만 생성
```

### 2. 캐시 친화적인 Dockerfile 순서

#### 자주 변경되는 코드를 먼저 복사
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY . .                    # 소스 변경 시 아래 모든 레이어 무효화
RUN npm install
CMD ["npm", "start"]
```

#### 의존성 파일을 먼저 복사
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./       # 의존성 변경 시에만 아래 레이어 무효화
RUN npm install
COPY . .                    # 소스 코드는 나중에 복사
CMD ["npm", "start"]
```

## 실습: 캐시 최적화 비교 실험

### 1. 비최적화 버전 빌드
```bash
mkdir cache-optimization-test
cd cache-optimization-test

# 비효율적인 Dockerfile 작성
cat > Dockerfile.bad << EOF
FROM node:18-alpine
WORKDIR /app

# 모든 파일을 먼저 복사 (비효율적)
COPY . .
RUN npm install
EXPOSE 3000
CMD ["npm", "start"]
EOF

# 더미 프로젝트 파일들 생성
cat > package.json << EOF
{
  "name": "cache-test",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "lodash": "^4.17.21"
  }
}
EOF

# 여러 소스 파일 생성
mkdir src
echo "console.log('app.js');" > src/app.js
echo "console.log('utils.js');" > src/utils.js
echo "console.log('config.js');" > src/config.js

# 첫 번째 빌드 시간 측정
echo "=== 비최적화 버전 첫 빌드 ==="
time docker build -f Dockerfile.bad -t cache-bad:v1 .

# 소스 파일 수정
echo "console.log('app.js - modified!');" > src/app.js

# 두 번째 빌드 시간 측정 (소스만 변경)
echo "=== 비최적화 버전 재빌드 (소스 변경) ==="
time docker build -f Dockerfile.bad -t cache-bad:v2 .
```

### 2. 최적화 버전 빌드
```bash
# 효율적인 Dockerfile 작성
cat > Dockerfile.good << EOF
FROM node:18-alpine
WORKDIR /app

# 의존성 파일만 먼저 복사 (효율적)
COPY package*.json ./
RUN npm install

# 소스 코드는 나중에 복사
COPY src/ ./src/
EXPOSE 3000
CMD ["npm", "start"]
EOF

# 첫 번째 빌드 시간 측정
echo "=== 최적화 버전 첫 빌드 ==="
time docker build -f Dockerfile.good -t cache-good:v1 .

# 소스 파일 수정 (동일한 변경)
echo "console.log('app.js - modified again!');" > src/app.js

# 두 번째 빌드 시간 측정
echo "=== 최적화 버전 재빌드 (소스 변경) ==="
time docker build -f Dockerfile.good -t cache-good:v2 .
```

### 3. 결과 비교 분석
```bash
# 이미지 크기 비교
echo "=== 이미지 크기 비교 ==="
docker images | grep cache-

# 빌드 시간 차이 확인
# 최적화된 버전은 소스 변경 시 npm install 단계를 건너뛰므로 훨씬 빠름
```

## 레이어 공유와 저장소 효율성

### 베이스 이미지 공유 확인
```bash
# 다양한 Node.js 애플리케이션 빌드
docker build -t app1 .
docker build -t app2 .  
docker build -t app3 .

# 베이스 이미지 레이어가 공유되어 디스크 사용량 절약 확인
docker system df -v

# 출력에서 "Shared Size" 확인 - 베이스 레이어들이 공유됨
```

### 레이어 중복 제거 효과
```bash
# 같은 베이스 이미지를 사용하는 여러 이미지들
docker images | grep node
docker images | grep alpine

# 실제 디스크 사용량은 레이어 공유로 인해 적음
du -sh /var/lib/docker/  # Linux
# 또는 Docker Desktop 설정에서 디스크 사용량 확인
```

## 고급 레이어 분석 도구

### 1. dive 도구를 사용한 레이어 분석
```bash
# dive 설치 (선택사항 - 이미지 레이어를 시각적으로 분석)
# https://github.com/wagoodman/dive

# dive로 이미지 분석 (설치된 경우)
# dive layer-example
```

### 2. Docker Desktop의 이미지 분석
```bash
# Docker Desktop GUI에서 Images 탭에서 이미지 선택
# Layer 탭에서 각 레이어의 크기와 내용 확인 가능
```

### 3. 명령행에서 레이어 상세 분석
```bash
# 이미지의 각 레이어 ID와 크기 확인
docker history layer-example --format "table {{.ID}}\t{{.Size}}\t{{.CreatedBy}}"

# 특정 레이어의 변경 사항 확인
docker diff $(docker create layer-example)
```

## 멀티 스테이지 빌드와 레이어

### 레이어 최적화의 궁극적 해결책
```dockerfile
# 빌드 스테이지 - 개발 도구 포함
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install              # 개발 의존성 포함
COPY . .
RUN npm run build           # 빌드 아티팩트 생성

# 프로덕션 스테이지 - 최종 이미지
FROM node:18-alpine         # 경량 베이스
WORKDIR /app
COPY --from=builder /app/dist ./dist    # 빌드 결과물만 복사
COPY --from=builder /app/node_modules ./node_modules  # 런타임 의존성만
EXPOSE 3000
CMD ["npm", "start"]

# 결과: 빌드 도구들은 최종 이미지에 포함되지 않음 (크기 대폭 감소)
```

## 레이어 보안 고려사항

### 민감한 정보 누출 방지
```dockerfile
# 위험한 방법 - 비밀 정보가 레이어에 남음
FROM alpine
RUN echo "secret-password" > /tmp/secret
RUN rm /tmp/secret  # 삭제해도 이전 레이어에 여전히 존재

# 안전한 방법 - 한 레이어에서 처리
FROM alpine  
RUN echo "처리 중..." && \
    # 필요한 작업 수행 후 \
    echo "완료" # 비밀 정보를 레이어에 남기지 않음
```

### 빌드 시크릿 사용 (BuildKit)
```dockerfile
# syntax=docker/dockerfile:1
FROM alpine
RUN --mount=type=secret,id=mypassword \
    cat /run/secrets/mypassword
# 빌드 시크릿은 최종 이미지에 포함되지 않음
```

## 레이어 최적화 체크리스트

### 해야 할 것들
1. **자주 변경되지 않는 명령어를 먼저 배치**
2. **RUN 명령어 결합으로 레이어 수 최소화**
3. **의존성 파일을 소스 코드보다 먼저 복사**
4. **불필요한 파일은 .dockerignore로 제외**
5. **멀티 스테이지 빌드로 최종 이미지 크기 최소화**

### 하지 말아야 할 것들
1. **매번 변경되는 파일을 Dockerfile 상단에 배치**
2. **불필요한 패키지나 파일을 설치한 후 삭제**
3. **민감한 정보를 중간 레이어에 포함**
4. **캐시를 고려하지 않은 명령어 순서**

## 요약

Docker 이미지 레이어를 이해하면:
- **빌드 시간을 대폭 단축**할 수 있습니다
- **디스크 공간을 효율적으로 사용**할 수 있습니다  
- **이미지 크기를 최소화**할 수 있습니다
- **보안성을 향상**시킬 수 있습니다

다음 섹션에서는 이러한 레이어 지식을 바탕으로 한 고급 최적화 기법을 학습하겠습니다!