---
title: '3.4 도커 이미지와 이미지 레이어 이해하기'
categoryPath:
  - 'Docker'
  - '3장 도커 이미지 만들기'
  - '3.4 도커 이미지와 이미지 레이어 이해하기'
authorNick: '관리자'
createdAt: '2025-08-27'
updateMode: 'upsert'
---

# 3.4 도커 이미지와 이미지 레이어 이해하기

도커 이미지에는 우리가 패키징에 포함시킨 모든 파일이 들어 있습니다.  
이들 파일은 나중에 컨테이너의 파일 시스템을 형성합니다.  
이 외에도 이미지에는 여러 **메타데이터 정보**가 들어 있는데, 이 정보를 이용하면 이미지를 구성하는 각 레이어는 무엇이고 어떤 명령으로 빌드되었는지 확인할 수 있습니다.

## 왜 이미지 레이어가 필요할까?

### 기존 방식의 문제점

도커 이미지는 컨테이너를 생성하기 위한 모든 정보를 갖고 있기 때문에 보통 **수백MB ~ 수GB**가 넘습니다.

**문제 상황:**

- 기존 이미지에서 코드 한 줄만 추가
- 이미지의 불변성 때문에 전체 이미지를 다시 다운로드
- 겨우 작은 변경사항인데 수백MB ~ 수GB를 다시 받아야 함
- 매우 비효율적!

**Docker는 이러한 문제를 해결하기 위해 Layer(레이어)라는 개념을 도입했습니다.**

**레이어란** 기존 이미지에 추가적인 파일이 필요할 때 다시 다운로드 받는 방법이 아닌 **해당 파일을 추가하기 위한 개념**입니다.

```
Ubuntu vs Nginx 이미지 예시:
┌─────────────────┐    ┌─────────────────┐
│   Ubuntu 이미지  │    │   Nginx 이미지   │
├─────────────────┤    ├─────────────────┤
│     Layer C     │    │   Nginx Layer   │ ← 이 부분만 추가 다운로드
├─────────────────┤    ├─────────────────┤
│     Layer B     │ ←→ │     Layer B     │ ← 공유
├─────────────────┤    ├─────────────────┤
│     Layer A     │ ←→ │     Layer A     │ ← 공유
└─────────────────┘    └─────────────────┘
```

만약 Ubuntu 이미지가 기존에 존재하는데 Nginx 이미지를 다운받을 경우 **Nginx 레이어만 다운로드**하게 됩니다.

<br/>

## 이미지 레이어란 무엇인가?

**도커 이미지는 이미지 레이어가 모인 논리적 대상**입니다.  
레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일입니다.

### 레이어 생성 과정

Dockerfile의 각 인스트럭션이 새로운 레이어를 만듭니다:

```dockerfile
FROM diamol/node          # Layer 1: Node.js 베이스 이미지
ENV TARGET="blog.sixeyed.com"  # Layer 2: 환경변수 설정
ENV METHOD="HEAD"         # Layer 3: 환경변수 설정
ENV INTERVAL="3000"       # Layer 4: 환경변수 설정
WORKDIR /web-ping         # Layer 5: 작업 디렉터리 설정
COPY app.js .            # Layer 6: 애플리케이션 파일 복사
CMD ["node", "/web-ping/app.js"]  # Layer 7: 실행 명령
```

```
web-ping 도커 이미지 구조
┌─────────────────────────────────────┐
│     CMD 실행 명령 (Layer 7)         │
├─────────────────────────────────────┤
│     app.js 파일 복사 (Layer 6)      │
├─────────────────────────────────────┤
│     작업 디렉터리 설정 (Layer 5)    │
├─────────────────────────────────────┤
│     INTERVAL 환경변수 (Layer 4)     │
├─────────────────────────────────────┤
│     METHOD 환경변수 (Layer 3)       │
├─────────────────────────────────────┤
│     TARGET 환경변수 (Layer 2)       │
├─────────────────────────────────────┤
│     Node.js 베이스 이미지 (Layer 1) │
└─────────────────────────────────────┘
        물리적 저장소에 각각 저장
```

### 레이어 확인하기

빌드한 이미지의 레이어를 확인해보겠습니다:

```bash
# web-ping 이미지의 레이어 히스토리 확인
docker history web-ping
```

**출력 예시:**

```
IMAGE          CREATED          CREATED BY                                      SIZE
b29fb0999b88   2 minutes ago    CMD ["node" "/web-ping/app.js"]                0B
c34fg1000c99   2 minutes ago    COPY app.js .                                   156B
d45gh2111d00   2 minutes ago    WORKDIR /web-ping                              0B
e56hi3222e11   2 minutes ago    ENV INTERVAL=3000                              0B
f67ij4333f22   2 minutes ago    ENV METHOD=HEAD                                0B
g78jk5444g33   2 minutes ago    ENV TARGET=blog.sixeyed.com                    0B
h89kl6555h44   3 weeks ago      FROM diamol/node                               800MB
```

<br/>

## 레이어 공유의 중요성

**이미지 레이어는 여러 이미지와 컨테이너에서 공유되기 때문에 중요**합니다.  
만약 Node.js 애플리케이션이 실행되는 컨테이너를 여러 개 실행한다면, 이들 컨테이너는 모두 Node.js 런타임이 들어 있는 이미지 레이어를 공유합니다.

### 레이어 공유 예시

```bash
# 첫 번째 Node.js 앱
FROM node:18
COPY app1.js .
CMD ["node", "app1.js"]

# 두 번째 Node.js 앱
FROM node:18
COPY app2.js .
CMD ["node", "app2.js"]

# 세 번째 Node.js 앱
FROM node:18
COPY app3.js .
CMD ["node", "app3.js"]
```

이 경우 `node:18` 베이스 이미지 레이어는 **한 번만 다운로드**되고 **세 이미지가 모두 공유**합니다.

```
메모리/디스크 사용량:
┌──────────────────┐
│  node:18 레이어   │ ← 한 번만 저장 (공유)
├──────────────────┤
│   app1.js 레이어  │ ← 앱1 전용
├──────────────────┤
│   app2.js 레이어  │ ← 앱2 전용
├──────────────────┤
│   app3.js 레이어  │ ← 앱3 전용
└──────────────────┘
```

### Docker 레이어의 특징

Docker 이미지는 **여러 레이어로 구성**되며, **각 레이어는 이전 레이어의 변경 사항**을 가지고 있습니다.

1. **레이어 격리**: 각 레이어는 독립적인 파일 시스템으로, 각 레이어에 애플리케이션과 종속성에 대한 변경 사항만 포함
2. **레이어 재사용**: 동일한 레이어를 여러 이미지에 공유할 수 있어 이미지 빌드 시간과 저장소 사용량을 절약
3. **레이어 버전 관리**: 레이어를 생성할 때마다 새로운 버전이 만들어져 애플리케이션의 변경 이력을 관리 가능
4. **Dockerfile 기반 레이어 생성**: Dockerfile에서 작성된 명령어들이 각각 실행될 때마다 새로운 레이어가 생성

**Git과의 유사성:** 이러한 개념은 **Git 레포지토리에 commit 로그를 쌓는 것과 같습니다**. 기존 레이어는 그대로 둔 채 새로 업데이트된 내용만 담고 있는 레이어만 쌓는 방식으로 관리됩니다.

<details>
<summary><strong>레이어 작동 원리</strong></summary>

**Docker 레이어의 작동 원리:**

1. Docker 이미지를 생성할 때, Dockerfile을 사용하여 이미지 레시피를 정의
2. Dockerfile에 기술된 명령어들이 순서대로 실행
3. 각 명령어가 실행될 때마다 새로운 레이어가 생성되고, 변경 사항이 레이어에 저장
4. Docker 이미지를 실행할 때, 해당 이미지의 모든 레이어가 연결되어 전체 파일 시스템을 구성
5. 컨테이너 내에서 변경해 저장한 것은 컨테이너의 최상단 레이어에 저장되며 이미지의 레이어에는 영향을 주지 않음

</details>

<br/>

## 읽기 전용 레이어

**이미지 레이어를 여러 이미지가 공유하기 때문에 공유되는 레이어는 수정할 수 없어야** 합니다.  
만약 이미지 레이어를 수정할 수 있다면 다른 이미지에도 영향을 미칩니다.

**도커는 이미지 레이어를 읽기 전용으로 만들어 이를 방지**합니다.  
이미지를 빌드하며 레이어가 만들어지면 다른 이미지에서 재사용될 수 있지만, 수정할 수는 없습니다.

### 컨테이너 실행 시 레이어 구조

```
컨테이너 실행 시:
┌─────────────────────────────────────┐
│     컨테이너 레이어 (읽기/쓰기)     │ ← 새로 생성, 컨테이너별 독립
├─────────────────────────────────────┤
│       app.js 레이어 (읽기 전용)     │ ← 이미지 레이어
├─────────────────────────────────────┤
│      환경변수 레이어 (읽기 전용)    │ ← 이미지 레이어
├─────────────────────────────────────┤
│     Node.js 레이어 (읽기 전용)      │ ← 이미지 레이어 (공유)
└─────────────────────────────────────┘
```

컨테이너가 실행되면:

- **이미지 레이어들**: 읽기 전용으로 공유
- **컨테이너 레이어**: 읽기/쓰기 가능, 컨테이너별 독립

<br/>

## 주요 태그와 용어 정리

### 레이어 관련 명령어

| 명령어             | 설명                        | 예시                      |
| ------------------ | --------------------------- | ------------------------- |
| `docker history`   | 이미지 레이어 히스토리 확인 | `docker history web-ping` |
| `docker inspect`   | 이미지 상세 정보 확인       | `docker inspect web-ping` |
| `docker system df` | 도커 시스템 디스크 사용량   | `docker system df -v`     |
| `docker image ls`  | 이미지 목록과 크기 확인     | `docker image ls`         |

### 주요 용어

- **이미지 레이어**: Dockerfile 인스트럭션이 만드는 읽기 전용 파일 시스템 조각
- **레이어 캐시**: 빌드 성능 향상을 위한 레이어 재사용 메커니즘
- **레이어 공유**: 여러 이미지나 컨테이너가 동일한 레이어를 공유하는 것
- **컨테이너 레이어**: 컨테이너 실행 시 생성되는 읽기/쓰기 가능한 최상위 레이어
- **베이스 이미지**: Dockerfile의 FROM으로 지정하는 기반 이미지

<br/>

## 연습 문제

**문제 1:** 도커가 이미지 레이어를 도입한 이유는 무엇인가요?

<details>
<summary><strong>정답 보기</strong></summary>

기존 방식에서는 작은 변경사항(코드 한 줄 추가)이 있어도 전체 이미지(수백MB~수GB)를 다시 다운로드해야 했습니다. 레이어를 도입함으로써 **변경된 부분만 다운로드**하고 **기존 레이어는 재사용**할 수 있게 되어 효율성을 크게 향상시켰습니다.

</details>

<br/>

**문제 2:** 여러 개의 Node.js 애플리케이션 이미지가 있을 때, 레이어 공유는 어떻게 이루어지나요?

<details>
<summary><strong>정답 보기</strong></summary>

모든 Node.js 애플리케이션이 같은 베이스 이미지(예: `node:18`)를 사용한다면, **베이스 이미지 레이어는 한 번만 저장**되고 **모든 애플리케이션이 공유**합니다. 각 애플리케이션의 고유한 코드 부분만 별도 레이어로 저장되어 디스크 공간을 절약할 수 있습니다.

</details>

<br/>

**문제 3:** 컨테이너 실행 시 이미지 레이어와 컨테이너 레이어의 차이점은 무엇인가요?

<details>
<summary><strong>정답 보기</strong></summary>

- **이미지 레이어**: 읽기 전용(Read-Only)으로 여러 컨테이너가 공유하며 수정할 수 없음
- **컨테이너 레이어**: 읽기/쓰기(Read/Write) 가능한 최상위 레이어로 컨테이너별로 독립적이며, 애플리케이션 실행 중 생성되는 모든 변경사항이 여기에 저장됨

이를 통해 **이미지의 불변성을 유지**하면서 컨테이너별 독립적인 작업이 가능합니다.
