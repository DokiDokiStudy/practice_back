---
title: "3.6 연습 문제"
categoryPath:
  - "Docker"
  - "3장 도커 이미지 만들기"
  - "3.6 연습 문제"
authorNick: "관리자"
createdAt: "2025-08-27"
updateMode: "upsert"
---

이번 장에서 학습한 내용을 바탕으로 실습을 통해 실력을 점검해보세요. 단계별로 진행하면서 Docker 이미지 생성의 전 과정을 마스터할 수 있습니다.

## 기본 실습 문제

### 문제 1: 정적 웹사이트 배포하기

**목표**: 간단한 HTML 파일을 만들어 Nginx 이미지에 복사하여 웹서버 구축

#### 단계별 실습 가이드

##### 1단계: 프로젝트 환경 준비
```bash
# 작업 디렉토리 생성
mkdir docker-nginx-practice
cd docker-nginx-practice

# 기본 HTML 파일 생성
cat > index.html << 'EOF'
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>내 첫 Docker 웹사이트</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            background: rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        .info {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Docker로 배포한 내 첫 웹사이트!</h1>
        <div class="info">
            <h3>Docker 학습 진행사항</h3>
            <ul>
                <li>Docker 기본 개념 이해</li>
                <li>컨테이너 실행 및 관리</li>
                <li>Docker 이미지 생성</li>
                <li>Dockerfile 작성</li>
                <li>현재: 웹서버 배포 실습</li>
            </ul>
        </div>
        <div class="info">
            <h3>서버 정보</h3>
            <p><strong>웹서버:</strong> Nginx</p>
            <p><strong>포트:</strong> 80</p>
            <p><strong>배포 시간:</strong> <span id="datetime"></span></p>
        </div>
        <div class="info">
            <h3>이번 실습에서 배운 것</h3>
            <ul>
                <li>정적 파일을 Docker 컨테이너로 배포하는 방법</li>
                <li>Nginx를 사용한 웹서버 구축</li>
                <li>Dockerfile을 통한 이미지 커스터마이징</li>
                <li>포트 매핑을 통한 서비스 노출</li>
            </ul>
        </div>
    </div>

    <script>
        // 현재 시간 표시
        document.getElementById('datetime').textContent = new Date().toLocaleString('ko-KR');
    </script>
</body>
</html>
EOF

echo "HTML 파일이 생성되었습니다!"
```

##### 2단계: Dockerfile 작성
```bash
cat > Dockerfile << 'EOF'
# 베이스 이미지로 Nginx 사용
FROM nginx:alpine

# HTML 파일을 Nginx의 기본 문서 루트로 복사
COPY index.html /usr/share/nginx/html/

# 포트 80 노출
EXPOSE 80

# Nginx 실행 (기본 CMD 사용)
EOF

echo "Dockerfile이 생성되었습니다!"
```

##### 3단계: 이미지 빌드
```bash
# 이미지 빌드 (각 단계별 로그 확인)
docker build -t my-nginx-website .

# 빌드 결과 확인
docker images | grep my-nginx-website

echo "이미지 빌드가 완료되었습니다!"
```

##### 4단계: 컨테이너 실행 및 테스트
```bash
# 컨테이너 실행 (포트 8080으로 매핑)
docker run -d -p 8080:80 --name my-website my-nginx-website

# 컨테이너 상태 확인
docker ps | grep my-website

# 웹사이트 접속 테스트
curl http://localhost:8080

echo "웹사이트가 성공적으로 배포되었습니다!"
echo "브라우저에서 http://localhost:8080 접속하여 확인하세요!"
```

##### 5단계: 추가 파일로 기능 확장
```bash
# CSS 파일 생성
mkdir css
cat > css/style.css << 'EOF'
/* 추가 스타일링 */
.footer {
    text-align: center;
    margin-top: 30px;
    padding: 20px;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
}

.docker-logo {
    font-size: 2em;
    animation: spin 10s linear infinite;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
EOF

# JavaScript 파일 생성
mkdir js  
cat > js/app.js << 'EOF'
// 동적 컨텐츠 추가
document.addEventListener('DOMContentLoaded', function() {
    // 방문자 수 시뮬레이션
    const visitors = Math.floor(Math.random() * 1000) + 1;
    
    // Footer 추가
    const footer = document.createElement('div');
    footer.className = 'footer';
    footer.innerHTML = `
        <div class="docker-logo">🐳</div>
        <p>Docker 실습 완료! 방문자 수: ${visitors}명</p>
        <p>Made with and Docker</p>
    `;
    
    document.querySelector('.container').appendChild(footer);
});
EOF

# HTML 파일 업데이트 (CSS, JS 링크 추가)
cat > index.html << 'EOF'
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>내 첫 Docker 웹사이트</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            background: rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        .info {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Docker로 배포한 내 첫 웹사이트!</h1>
        <div class="info">
            <h3>Docker 학습 진행사항</h3>
            <ul>
                <li>Docker 기본 개념 이해</li>
                <li>컨테이너 실행 및 관리</li>
                <li>Docker 이미지 생성</li>
                <li>Dockerfile 작성</li>
                <li>웹서버 배포 실습 완료!</li>
            </ul>
        </div>
        <div class="info">
            <h3>서버 정보</h3>
            <p><strong>웹서버:</strong> Nginx</p>
            <p><strong>포트:</strong> 80</p>
            <p><strong>배포 시간:</strong> <span id="datetime"></span></p>
        </div>
        <div class="info">
            <h3>이번 실습에서 배운 것</h3>
            <ul>
                <li>정적 파일을 Docker 컨테이너로 배포하는 방법</li>
                <li>Nginx를 사용한 웹서버 구축</li>
                <li>Dockerfile을 통한 이미지 커스터마이징</li>
                <li>포트 매핑을 통한 서비스 노출</li>
                <li>정적 자원(CSS, JS) 포함한 웹사이트 구축</li>
            </ul>
        </div>
    </div>

    <script src="js/app.js"></script>
    <script>
        document.getElementById('datetime').textContent = new Date().toLocaleString('ko-KR');
    </script>
</body>
</html>
EOF

# Dockerfile 업데이트
cat > Dockerfile << 'EOF'
FROM nginx:alpine

# 모든 웹 자원을 복사
COPY index.html /usr/share/nginx/html/
COPY css/ /usr/share/nginx/html/css/
COPY js/ /usr/share/nginx/html/js/

EXPOSE 80
EOF

# 기존 컨테이너 정지 및 제거
docker stop my-website
docker rm my-website

# 새로운 이미지 빌드
docker build -t my-nginx-website:v2 .

# 업데이트된 컨테이너 실행
docker run -d -p 8080:80 --name my-website-v2 my-nginx-website:v2

echo "웹사이트가 업그레이드되었습니다!"
echo "브라우저에서 http://localhost:8080 접속하여 새로운 기능을 확인하세요!"
```

---

## 중급 실습 문제

### 문제 2: Node.js API 서버 컨테이너화

**목표**: Express.js를 사용한 REST API 서버를 Docker로 컨테이너화

#### 실습 가이드
```bash
# 프로젝트 준비
mkdir docker-nodejs-api
cd docker-nodejs-api

# package.json 생성
cat > package.json << 'EOF'
{
  "name": "docker-api-demo",
  "version": "1.0.0",
  "description": "Docker로 배포하는 Node.js API",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
EOF

# Express 서버 코드 생성
cat > server.js << 'EOF'
const express = require('express');
const cors = require('cors');

const app = express();
const PORT = process.env.PORT || 3000;

// 미들웨어
app.use(cors());
app.use(express.json());

// 더미 데이터
let todos = [
  { id: 1, text: 'Docker 학습하기', completed: false },
  { id: 2, text: 'Node.js API 만들기', completed: true },
  { id: 3, text: '컨테이너 배포하기', completed: false }
];

// 라우트
app.get('/', (req, res) => {
  res.json({
    message: 'Docker로 배포된 Node.js API 서버입니다!',
    version: '1.0.0',
    endpoints: {
      'GET /': '서버 정보',
      'GET /todos': '할일 목록 조회',
      'POST /todos': '할일 추가',
      'PUT /todos/:id': '할일 수정',
      'DELETE /todos/:id': '할일 삭제'
    }
  });
});

// 할일 목록 조회
app.get('/todos', (req, res) => {
  res.json(todos);
});

// 할일 추가
app.post('/todos', (req, res) => {
  const { text } = req.body;
  if (!text) {
    return res.status(400).json({ error: 'text 필드가 필요합니다' });
  }
  
  const newTodo = {
    id: Math.max(...todos.map(t => t.id)) + 1,
    text,
    completed: false
  };
  
  todos.push(newTodo);
  res.status(201).json(newTodo);
});

// 할일 수정
app.put('/todos/:id', (req, res) => {
  const id = parseInt(req.params.id);
  const { text, completed } = req.body;
  
  const todoIndex = todos.findIndex(t => t.id === id);
  if (todoIndex === -1) {
    return res.status(404).json({ error: '할일을 찾을 수 없습니다' });
  }
  
  if (text !== undefined) todos[todoIndex].text = text;
  if (completed !== undefined) todos[todoIndex].completed = completed;
  
  res.json(todos[todoIndex]);
});

// 할일 삭제
app.delete('/todos/:id', (req, res) => {
  const id = parseInt(req.params.id);
  const todoIndex = todos.findIndex(t => t.id === id);
  
  if (todoIndex === -1) {
    return res.status(404).json({ error: '할일을 찾을 수 없습니다' });
  }
  
  const deletedTodo = todos.splice(todoIndex, 1)[0];
  res.json(deletedTodo);
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`서버가 포트 ${PORT}에서 실행 중입니다`);
  console.log(`API 엔드포인트: http://localhost:${PORT}`);
});
EOF

# 최적화된 Dockerfile 작성
cat > Dockerfile << 'EOF'
# 멀티 스테이지 빌드 사용
FROM node:18-alpine AS base
WORKDIR /app

# 의존성 파일만 먼저 복사 (캐시 최적화)
COPY package*.json ./

# 프로덕션 의존성만 설치
FROM base AS dependencies
RUN npm ci --only=production && npm cache clean --force

# 개발 단계 (선택사항)
FROM base AS development  
RUN npm ci
COPY . .
CMD ["npm", "run", "dev"]

# 프로덕션 단계
FROM dependencies AS production
COPY . .

# 보안을 위한 non-root 사용자 생성
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodeuser -u 1001

# 앱 디렉토리 소유권 변경
RUN chown -R nodeuser:nodejs /app
USER nodeuser

EXPOSE 3000
CMD ["npm", "start"]
EOF

# .dockerignore 파일 생성
cat > .dockerignore << 'EOF'
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.git/
.gitignore
README.md
Dockerfile*
docker-compose*.yml
.dockerignore
coverage/
.nyc_output/
.env.local
.env.development
.env.test
EOF

echo "Node.js API 프로젝트가 준비되었습니다!"

# 이미지 빌드
docker build -t nodejs-api .

# 컨테이너 실행
docker run -d -p 3000:3000 --name api-server nodejs-api

echo "API 서버가 실행되었습니다!"
echo "http://localhost:3000 에서 API를 테스트하세요!"

# API 테스트 명령어
echo ""
echo "API 테스트 명령어:"
echo "curl http://localhost:3000"
echo "curl http://localhost:3000/todos"
echo "curl -X POST http://localhost:3000/todos -H 'Content-Type: application/json' -d '{\"text\":\"새 할일\"}'"
```

---

## 고급 실습 문제

### 문제 3: 캐시 최적화 챌린지

**목표**: 주어진 비효율적인 Dockerfile을 최적화하여 빌드 성능 향상

#### 문제 상황
```bash
mkdir cache-optimization-challenge
cd cache-optimization-challenge

# 비효율적인 Dockerfile (문제 코드)
cat > Dockerfile.inefficient << 'EOF'
FROM node:18

# 문제점들이 포함된 Dockerfile
WORKDIR /app

# 모든 파일을 먼저 복사 (비효율적!)
COPY . .

# 각각 별도로 실행 (레이어 낭비!)
RUN apt-get update
RUN apt-get install -y python3
RUN apt-get install -y python3-pip
RUN apt-get install -y git
RUN apt-get install -y vim

# npm 의존성 설치 (캐시 활용 못함!)
RUN npm install

# 불필요한 개발 의존성도 설치
RUN npm install --also=dev

EXPOSE 3000
CMD ["npm", "start"]
EOF

# 더미 프로젝트 생성
cat > package.json << 'EOF'
{
  "name": "cache-challenge",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "nodemon": "^3.0.1",
    "jest": "^29.0.0"
  },
  "scripts": {
    "start": "node app.js",
    "dev": "nodemon app.js",
    "test": "jest"
  }
}
EOF

cat > app.js << 'EOF'
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.json({ message: 'Cache Optimization Challenge!' });
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
EOF

# 불필요한 파일들 생성 (최적화 테스트용)
mkdir -p logs temp docs tests
dd if=/dev/zero of=logs/app.log bs=1M count=10 2>/dev/null
dd if=/dev/zero of=temp/cache.tmp bs=1M count=20 2>/dev/null
echo "# Documentation" > docs/README.md
echo "test file" > tests/app.test.js

echo "캐시 최적화 챌린지!"
echo ""
echo "현재 Dockerfile의 문제점을 찾고 최적화하세요:"
echo "1. 빌드 시간 측정"
echo "2. 문제점 분석" 
echo "3. 최적화 적용"
echo "4. 성능 비교"
echo ""

# 최적화 전 빌드 시간 측정
echo "=== 최적화 전 빌드 시간 ==="
time docker build -f Dockerfile.inefficient -t challenge-before .

echo ""
echo "최적화 힌트:"
echo "- 의존성 파일을 먼저 복사하세요"
echo "- RUN 명령어를 결합하세요"
echo "- .dockerignore를 활용하세요"
echo "- 멀티 스테이지 빌드를 고려하세요"
echo ""
echo "📝 Dockerfile.optimized를 작성하여 최적화해보세요!"
```

#### 최적화 솔루션 (참고용)
```dockerfile
# Dockerfile.optimized - 최적화 솔루션
FROM node:18-alpine AS base
WORKDIR /app

# 1. 의존성 파일만 먼저 복사 (캐시 최적화)
COPY package*.json ./

# 2. 의존성 설치 (프로덕션만)
RUN npm ci --only=production && npm cache clean --force

# 3. 소스 코드 복사 (자주 변경되므로 나중에)
COPY app.js ./

# 4. 보안: non-root 사용자
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodeuser -u 1001 && \
    chown -R nodeuser:nodejs /app

USER nodeuser

EXPOSE 3000
CMD ["npm", "start"]
```

```bash
# .dockerignore (최적화용)
cat > .dockerignore << 'EOF'
node_modules/
logs/
temp/
docs/
tests/
*.log
*.tmp
.git/
.gitignore
README.md
Dockerfile*
.dockerignore
EOF

# 최적화 후 테스트
echo "=== 최적화 후 빌드 시간 ==="
time docker build -f Dockerfile.optimized -t challenge-after .

echo ""
echo "성능 비교:"
docker images | grep challenge-
```

---

## 실습 점검 체크리스트

### 완료 확인 사항

#### 기본 실습 (문제 1)
- [ ] HTML 파일을 성공적으로 생성했나요?
- [ ] Dockerfile을 올바르게 작성했나요?  
- [ ] 이미지가 정상적으로 빌드되었나요?
- [ ] 컨테이너가 실행되고 포트 매핑이 되었나요?
- [ ] 브라우저에서 웹사이트에 접속할 수 있나요?

#### 중급 실습 (문제 2)
- [ ] Node.js 프로젝트 구조가 올바른가요?
- [ ] API 엔드포인트들이 정상 작동하나요?
- [ ] 멀티 스테이지 빌드를 적용했나요?
- [ ] .dockerignore를 활용했나요?
- [ ] 보안 모범사례(non-root 사용자)를 적용했나요?

#### 고급 실습 (문제 3)
- [ ] 원본 Dockerfile의 문제점을 파악했나요?
- [ ] 레이어 캐시 최적화를 적용했나요?
- [ ] 빌드 시간이 현저히 개선되었나요?
- [ ] 이미지 크기가 최적화되었나요?
- [ ] 캐시 히트율이 향상되었나요?

---

## 다음 단계 준비

### 4장 예습 가이드

다음 장에서 배울 내용들:
1. **애플리케이션 소스 코드에서 Docker 이미지까지**
2. **실제 프로덕션 환경 배포 시나리오**
3. **CI/CD 파이프라인 통합**
4. **고급 이미지 관리 전략**

### 추가 연습 과제

시간이 있다면 도전해보세요:
- **Python Flask 앱 컨테이너화**
- **React + Node.js 풀스택 앱 배포**
- **데이터베이스 연동 애플리케이션**
- **로드 밸런서를 포함한 멀티 컨테이너 구성**

축하합니다! Docker 이미지 만들기를 완벽하게 마스터했습니다!