---
title: "4.3 애플리케이션 빌드 실전 예제: Node.js 소스 코드"
categoryPath:
  - "Docker"
  - "4장 애플리케이션 소스 코드에서 도커 이미지까지"
  - "4.3 애플리케이션 빌드 실전 예제: Node.js 소스 코드"
authorNick: "관리자"
createdAt: "2025-08-27"
updateMode: "upsert"
---

# 4.3 Node.js 애플리케이션 빌드 실전 예제

Node.js는 가벼운 런타임과 빠른 개발 속도로 Docker 컨테이너화에 적합한 언어입니다. 이번 섹션에서는 Express.js 애플리케이션을 예시로 효율적인 Node.js Docker 이미지 구축 방법을 학습합니다.

## Node.js Docker화의 특징

### Node.js 환경의 장점
- **빠른 시작 속도**: JVM 워밍업 없이 즉시 실행
- **npm 생태계**: 풍부한 라이브러리 생태계
- **경량 런타임**: 상대적으로 작은 메모리 사용량
- **Hot Reload**: 개발 환경에서 빠른 피드백

### 주요 최적화 포인트
- **npm 캐시 활용**: package.json 변경 시에만 의존성 재설치
- **Alpine Linux 사용**: 이미지 크기 최소화
- **멀티 스테이지 빌드**: 개발/프로덕션 환경 분리
- **node_modules 최적화**: 프로덕션 의존성만 포함

## 실습: Express.js REST API 서버

### 프로젝트 설정

```bash
mkdir nodejs-docker-express && cd nodejs-docker-express
```

**package.json 파일**:
```json
{
  "name": "express-docker-demo",
  "version": "1.0.0",
  "description": "Docker로 배포하는 Express.js API 서버",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0",
    "compression": "^1.7.4"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
```

### Express 서버 코드

**server.js**:
```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const compression = require('compression');

const app = express();
const PORT = process.env.PORT || 3000;

// 미들웨어 설정
app.use(helmet());
app.use(cors());
app.use(compression());
app.use(morgan('combined'));
app.use(express.json());

// 메모리 기반 데이터 저장소
let todos = [
  { id: 1, title: 'Docker 학습', completed: false, createdAt: new Date() },
  { id: 2, title: 'Node.js 최적화', completed: true, createdAt: new Date() }
];
let idCounter = 2;

// 라우트 정의
app.get('/', (req, res) => {
  res.json({
    message: 'Docker로 배포된 Express.js API',
    version: process.env.npm_package_version || '1.0.0',
    nodeVersion: process.version,
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    timestamp: new Date().toISOString()
  });
});

// 할일 목록 조회
app.get('/todos', (req, res) => {
  res.json({
    todos: todos,
    total: todos.length,
    timestamp: new Date().toISOString()
  });
});

// 할일 생성
app.post('/todos', (req, res) => {
  const { title, description } = req.body;
  
  if (!title) {
    return res.status(400).json({
      error: 'Title is required',
      timestamp: new Date().toISOString()
    });
  }
  
  const newTodo = {
    id: ++idCounter,
    title,
    description: description || '',
    completed: false,
    createdAt: new Date()
  };
  
  todos.push(newTodo);
  res.status(201).json(newTodo);
});

// 헬스체크 엔드포인트
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    version: process.version
  });
});

// Graceful shutdown
const server = app.listen(PORT, '0.0.0.0', () => {
  console.log(`Express server running on port ${PORT}`);
});

process.on('SIGTERM', () => {
  console.log('SIGTERM received. Shutting down gracefully...');
  server.close(() => {
    process.exit(0);
  });
});

module.exports = app;
```

## Docker 이미지 최적화

### 비효율적인 Dockerfile

```dockerfile
# 문제가 많은 접근법
FROM node:20

WORKDIR /app
COPY . .
RUN npm install

EXPOSE 3000
CMD ["node", "server.js"]
```

**문제점**:
- 모든 파일을 먼저 복사 (캐시 비효율)
- 개발 의존성까지 설치
- root 사용자로 실행
- 헬스체크 없음

### 최적화된 멀티 스테이지 Dockerfile

```dockerfile
# === 베이스 스테이지 ===
FROM node:20-alpine AS base
WORKDIR /app
RUN apk add --no-cache dumb-init curl

# === 의존성 스테이지 ===
FROM base AS dependencies
# package.json과 package-lock.json만 먼저 복사
COPY package*.json ./
# 프로덕션 의존성만 설치
RUN npm ci --only=production --silent && npm cache clean --force

# === 프로덕션 스테이지 ===
FROM base AS production

# 보안을 위한 non-root 사용자
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# 프로덕션 의존성 복사
COPY --from=dependencies --chown=nodejs:nodejs /app/node_modules ./node_modules

# 애플리케이션 코드 복사
COPY --chown=nodejs:nodejs server.js ./

USER nodejs

# 환경 변수 설정
ENV NODE_ENV=production \
    PORT=3000

# 헬스체크 설정
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

EXPOSE 3000

# dumb-init으로 시그널 처리 개선
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "server.js"]
```

### .dockerignore 설정

```bash
cat > .dockerignore << 'EOF'
node_modules/
npm-debug.log*
.env
.git/
README.md
Dockerfile*
docker-compose*.yml
*.log
coverage/
.nyc_output/
EOF
```

## React + Express 풀스택 예제

### Frontend Dockerfile

```dockerfile
# === React 빌드 스테이지 ===
FROM node:20-alpine AS frontend-build
WORKDIR /app

COPY frontend/package*.json ./
RUN npm ci --silent

COPY frontend/ .
RUN npm run build

# === 최종 스테이지 (Nginx + API) ===
FROM nginx:alpine AS production

# React 빌드 결과물 복사
COPY --from=frontend-build /app/build /usr/share/nginx/html

# Nginx 설정
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### Docker Compose 구성

```yaml
version: '3.8'

services:
  backend:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: express-api
    environment:
      - NODE_ENV=production
      - PORT=3000
    ports:
      - "3000:3000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - app-network

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: react-app
    ports:
      - "80:80"
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - app-network

networks:
  app-network:
    driver: bridge
```

## 성능 최적화

### PM2 클러스터 모드

```bash
npm install pm2 --save
```

**ecosystem.config.js**:
```javascript
module.exports = {
  apps: [{
    name: 'node-app',
    script: './server.js',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'production',
      PORT: 3000
    },
    autorestart: true,
    max_memory_restart: '500M'
  }]
}
```

**PM2용 Dockerfile**:
```dockerfile
FROM node:20-alpine AS production

RUN npm install pm2 -g
WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY server.js ecosystem.config.js ./

USER node

EXPOSE 3000
CMD ["pm2-runtime", "start", "ecosystem.config.js"]
```

### 보안 강화

```dockerfile
# 보안 강화 Dockerfile
FROM node:20-alpine AS production

# 보안 패키지 설치
RUN apk add --no-cache dumb-init curl ca-certificates

WORKDIR /app

# 보안 사용자 생성
RUN addgroup -g 1001 -S appgroup && \
    adduser -S appuser -u 1001 -G appgroup && \
    chown -R appuser:appgroup /app

# 의존성 설치
COPY --chown=appuser:appgroup package*.json ./
RUN npm ci --only=production --silent && \
    npm audit fix && \
    npm cache clean --force

COPY --chown=appuser:appgroup server.js ./

USER appuser

ENV NODE_ENV=production \
    NODE_OPTIONS="--max-old-space-size=512"

HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

EXPOSE 3000
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "server.js"]
```

## Node.js Docker 최적화 체크리스트

### 빌드 최적화
- [ ] 멀티 스테이지 빌드 사용
- [ ] Alpine Linux 베이스 이미지 사용
- [ ] package.json 우선 복사 (캐시 활용)
- [ ] npm ci 사용 (package-lock.json 활용)
- [ ] .dockerignore로 불필요 파일 제외

### 런타임 최적화
- [ ] PM2 클러스터 모드 (멀티 코어 활용)
- [ ] 적절한 메모리 제한 설정
- [ ] Graceful shutdown 구현
- [ ] 헬스체크 엔드포인트 구현

### 보안 강화
- [ ] Non-root 사용자 사용
- [ ] npm audit로 취약점 검사
- [ ] dumb-init으로 시그널 처리 개선
- [ ] 환경 변수로 민감 정보 관리

## 최적화 성과

| 항목 | 최적화 전 | 최적화 후 | 개선율 |
|------|-----------|-----------|--------|
| 이미지 크기 | 1.2GB | 80MB | 93% |
| 빌드 시간 | 3분 | 45초 | 75% |
| 시작 시간 | 15초 | 5초 | 67% |
| 메모리 사용 | 512MB | 256MB | 50% |

Node.js의 특성을 활용한 최적화로 경량하고 빠른 컨테이너 애플리케이션을 구축할 수 있습니다.