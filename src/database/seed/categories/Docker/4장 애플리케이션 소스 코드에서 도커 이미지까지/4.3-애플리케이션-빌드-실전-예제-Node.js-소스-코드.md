---
title: "4.3 애플리케이션 빌드 실전 예제: Node.js 소스 코드"
categoryPath:
  - "Docker"
  - "4장 애플리케이션 소스 코드에서 도커 이미지까지"
  - "4.3 애플리케이션 빌드 실전 예제: Node.js 소스 코드"
authorNick: "관리자"
createdAt: "2025-08-27"
updateMode: "upsert"
---

Node.js는 경량성과 빠른 개발 속도로 인해 컨테이너화에 가장 적합한 언어 중 하나입니다. 하지만 동시에 `node_modules`의 복잡성, 보안 취약점, 그리고 다양한 프레임워크별 특성을 고려해야 하는 도전 과제들도 있습니다. 이번 섹션에서는 Express, React, Next.js, NestJS 등 다양한 Node.js 애플리케이션을 효율적으로 Docker화하는 방법을 실습을 통해 학습하겠습니다.

## Node.js Docker화의 핵심 전략

### Node.js 특성 기반 최적화 포인트

1. **npm/yarn 캐시 활용**: package.json 변경 시에만 의존성 재설치
2. **Alpine Linux 사용**: 이미지 크기 최소화 (1GB → 100MB)
3. **멀티 스테이지 빌드**: 개발/빌드/프로덕션 환경 분리
4. **보안 강화**: 취약점 스캔, non-root 사용자
5. **성능 최적화**: PM2, 클러스터 모드, 메모리 튜닝

## 실습 1: Express.js REST API 서버

### 프로젝트 설정

```bash
# Express.js 프로젝트 생성
mkdir nodejs-docker-express
cd nodejs-docker-express

# package.json 생성
cat > package.json << 'EOF'
{
  "name": "express-docker-demo",
  "version": "1.0.0",
  "description": "Docker로 배포하는 Express.js API 서버",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest --coverage",
    "lint": "eslint .",
    "security-audit": "npm audit"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0",
    "compression": "^1.7.4",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.7.0",
    "supertest": "^6.3.3",
    "eslint": "^8.55.0"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
EOF

# Express 서버 코드
cat > server.js << 'EOF'
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const compression = require('compression');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// 보안 및 성능 미들웨어
app.use(helmet());
app.use(cors());
app.use(compression());
app.use(morgan('combined'));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// 메모리 기반 데이터 저장소 (데모용)
let todos = [
  { id: 1, title: 'Docker 학습', completed: false, createdAt: new Date() },
  { id: 2, title: 'Node.js 최적화', completed: true, createdAt: new Date() }
];
let idCounter = 2;

// 라우트 정의
app.get('/', (req, res) => {
  res.json({
    message: 'Docker로 배포된 Express.js API!',
    version: process.env.npm_package_version || '1.0.0',
    environment: process.env.NODE_ENV || 'development',
    nodeVersion: process.version,
    platform: process.platform,
    arch: process.arch,
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    timestamp: new Date().toISOString(),
    endpoints: {
      'GET /': '서버 정보',
      'GET /todos': '할일 목록 조회',
      'POST /todos': '할일 생성',
      'GET /todos/:id': '특정 할일 조회',
      'PUT /todos/:id': '할일 수정',
      'DELETE /todos/:id': '할일 삭제',
      'GET /health': '헬스체크'
    }
  });
});

// 할일 목록 조회
app.get('/todos', (req, res) => {
  const { page = 1, limit = 10, completed } = req.query;
  let filteredTodos = todos;
  
  if (completed !== undefined) {
    filteredTodos = todos.filter(todo => todo.completed === (completed === 'true'));
  }
  
  const startIndex = (page - 1) * limit;
  const endIndex = startIndex + parseInt(limit);
  const paginatedTodos = filteredTodos.slice(startIndex, endIndex);
  
  res.json({
    todos: paginatedTodos,
    pagination: {
      currentPage: parseInt(page),
      totalItems: filteredTodos.length,
      totalPages: Math.ceil(filteredTodos.length / limit),
      itemsPerPage: parseInt(limit)
    },
    timestamp: new Date().toISOString()
  });
});

// 할일 생성
app.post('/todos', (req, res) => {
  const { title, description } = req.body;
  
  if (!title) {
    return res.status(400).json({
      error: 'Title is required',
      timestamp: new Date().toISOString()
    });
  }
  
  const newTodo = {
    id: ++idCounter,
    title,
    description: description || '',
    completed: false,
    createdAt: new Date(),
    updatedAt: new Date()
  };
  
  todos.push(newTodo);
  
  res.status(201).json({
    message: '할일이 생성되었습니다',
    todo: newTodo,
    timestamp: new Date().toISOString()
  });
});

// 특정 할일 조회
app.get('/todos/:id', (req, res) => {
  const id = parseInt(req.params.id);
  const todo = todos.find(t => t.id === id);
  
  if (!todo) {
    return res.status(404).json({
      error: `Todo with id ${id} not found`,
      timestamp: new Date().toISOString()
    });
  }
  
  res.json({
    todo,
    timestamp: new Date().toISOString()
  });
});

// 할일 수정
app.put('/todos/:id', (req, res) => {
  const id = parseInt(req.params.id);
  const { title, description, completed } = req.body;
  
  const todoIndex = todos.findIndex(t => t.id === id);
  if (todoIndex === -1) {
    return res.status(404).json({
      error: `Todo with id ${id} not found`,
      timestamp: new Date().toISOString()
    });
  }
  
  if (title) todos[todoIndex].title = title;
  if (description !== undefined) todos[todoIndex].description = description;
  if (completed !== undefined) todos[todoIndex].completed = completed;
  todos[todoIndex].updatedAt = new Date();
  
  res.json({
    message: '할일이 수정되었습니다',
    todo: todos[todoIndex],
    timestamp: new Date().toISOString()
  });
});

// 할일 삭제
app.delete('/todos/:id', (req, res) => {
  const id = parseInt(req.params.id);
  const todoIndex = todos.findIndex(t => t.id === id);
  
  if (todoIndex === -1) {
    return res.status(404).json({
      error: `Todo with id ${id} not found`,
      timestamp: new Date().toISOString()
    });
  }
  
  const deletedTodo = todos.splice(todoIndex, 1)[0];
  
  res.json({
    message: '할일이 삭제되었습니다',
    todo: deletedTodo,
    timestamp: new Date().toISOString()
  });
});

// 헬스체크 엔드포인트
app.get('/health', (req, res) => {
  const healthData = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    cpu: process.cpuUsage(),
    version: process.version,
    environment: process.env.NODE_ENV || 'development'
  };
  
  res.json(healthData);
});

// 에러 핸들링
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    error: 'Internal Server Error',
    timestamp: new Date().toISOString()
  });
});

// 404 핸들링
app.use((req, res) => {
  res.status(404).json({
    error: `Route ${req.originalUrl} not found`,
    timestamp: new Date().toISOString()
  });
});

// 서버 시작
const server = app.listen(PORT, '0.0.0.0', () => {
  console.log(`Express server running on port ${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`Process ID: ${process.pid}`);
  console.log(`Node.js version: ${process.version}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received. Shutting down gracefully...');
  server.close(() => {
    console.log('Express server closed');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('SIGINT received. Shutting down gracefully...');
  server.close(() => {
    console.log('Express server closed');
    process.exit(0);
  });
});

module.exports = app;
EOF

# 환경 변수 파일
cat > .env.example << 'EOF'
NODE_ENV=production
PORT=3000
LOG_LEVEL=info
EOF

# 간단한 테스트 파일
cat > server.test.js << 'EOF'
const request = require('supertest');
const app = require('./server');

describe('Express App', () => {
  test('GET / should return server info', async () => {
    const response = await request(app).get('/');
    expect(response.status).toBe(200);
    expect(response.body.message).toContain('Express.js API');
  });

  test('GET /todos should return todos list', async () => {
    const response = await request(app).get('/todos');
    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('todos');
    expect(response.body).toHaveProperty('pagination');
  });

  test('GET /health should return health status', async () => {
    const response = await request(app).get('/health');
    expect(response.status).toBe(200);
    expect(response.body.status).toBe('healthy');
  });
});
EOF

echo "Express.js 프로젝트 준비 완료!"
```

### 최적화된 Dockerfile 작성

#### 비효율적인 Dockerfile
```dockerfile
# 문제가 많은 Dockerfile
FROM node:20

WORKDIR /app

# 문제 1: 모든 파일을 먼저 복사 (캐시 비효율)
COPY . .

# 문제 2: root 사용자로 실행 (보안 위험)
# 문제 3: 개발 의존성까지 설치
RUN npm install

# 문제 4: 포트만 노출하고 헬스체크 없음
EXPOSE 3000
CMD ["node", "server.js"]
```

#### 최적화된 멀티 스테이지 Dockerfile
```dockerfile
# syntax=docker/dockerfile:1

# === 베이스 스테이지 ===
FROM node:20-alpine AS base
WORKDIR /app

# 시스템 패키지 업데이트 및 보안 패키지 설치
RUN apk update && apk add --no-cache \
    dumb-init \
    curl \
    && rm -rf /var/cache/apk/*

# === 의존성 스테이지 ===
FROM base AS dependencies

# package.json과 package-lock.json만 먼저 복사
COPY package*.json ./

# 프로덕션 의존성만 설치 (캐시 최적화)
RUN npm ci --only=production --silent && npm cache clean --force

# === 개발 의존성 스테이지 ===
FROM dependencies AS dev-dependencies
RUN npm ci --silent

# === 빌드 스테이지 (필요한 경우) ===
FROM dev-dependencies AS build
COPY . .
RUN npm run test && npm run lint

# === 프로덕션 스테이지 ===
FROM base AS production

# 보안을 위한 non-root 사용자 생성
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# 프로덕션 의존성 복사
COPY --from=dependencies --chown=nodejs:nodejs /app/node_modules ./node_modules

# 애플리케이션 코드 복사
COPY --chown=nodejs:nodejs server.js ./
COPY --chown=nodejs:nodejs .env.example ./.env

# 사용자 전환
USER nodejs

# 환경 변수 설정
ENV NODE_ENV=production \
    PORT=3000 \
    NPM_CONFIG_LOGLEVEL=warn

# 헬스체크 설정
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

EXPOSE 3000

# dumb-init으로 시그널 처리 개선
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "server.js"]
```

### .dockerignore 최적화
```bash
cat > .dockerignore << 'EOF'
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime
*.pid
*.seed
*.pid.lock

# Coverage
coverage/
.nyc_output/

# Environment
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
logs/
*.log

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Git
.git/
.gitignore

# Docker
Dockerfile*
docker-compose*.yml
.dockerignore

# Documentation
README.md
docs/
*.md

# Tests
test/
spec/
*.test.js
*.spec.js

# Build artifacts
build/
dist/
EOF
```

## 실습 2: React + Express 풀스택 애플리케이션

### React 프론트엔드 설정

```bash
# 풀스택 프로젝트 생성
mkdir nodejs-fullstack-docker
cd nodejs-fullstack-docker
mkdir frontend backend

# React 프론트엔드 (frontend 디렉토리)
cd frontend

cat > package.json << 'EOF'
{
  "name": "react-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "axios": "^1.6.0",
    "react-router-dom": "^6.17.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": ["last 1 chrome version", "last 1 firefox version", "last 1 safari version"]
  },
  "proxy": "http://backend:3001"
}
EOF

# React 앱 컴포넌트들 생성
mkdir -p src/components public

cat > public/index.html << 'EOF'
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Docker 풀스택 앱</title>
</head>
<body>
    <div id="root"></div>
</body>
</html>
EOF

cat > src/index.js << 'EOF'
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
EOF

cat > src/App.js << 'EOF'
import React, { useState, useEffect } from 'react';
import TodoList from './components/TodoList';
import './App.css';

function App() {
  const [todos, setTodos] = useState([]);
  const [newTodo, setNewTodo] = useState('');
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    fetchTodos();
  }, []);

  const fetchTodos = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/todos');
      const data = await response.json();
      setTodos(data.todos || []);
    } catch (error) {
      console.error('할일 조회 실패:', error);
    } finally {
      setLoading(false);
    }
  };

  const addTodo = async (e) => {
    e.preventDefault();
    if (!newTodo.trim()) return;

    try {
      const response = await fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title: newTodo })
      });
      
      if (response.ok) {
        setNewTodo('');
        fetchTodos();
      }
    } catch (error) {
      console.error('할일 추가 실패:', error);
    }
  };

  const toggleTodo = async (id, completed) => {
    try {
      const response = await fetch(`/api/todos/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ completed: !completed })
      });
      
      if (response.ok) {
        fetchTodos();
      }
    } catch (error) {
      console.error('할일 수정 실패:', error);
    }
  };

  const deleteTodo = async (id) => {
    try {
      const response = await fetch(`/api/todos/${id}`, {
        method: 'DELETE'
      });
      
      if (response.ok) {
        fetchTodos();
      }
    } catch (error) {
      console.error('할일 삭제 실패:', error);
    }
  };

  return (
    <div className="App">
      <header className="App-header">
        <h1>Docker 풀스택 할일 앱</h1>
        
        <form onSubmit={addTodo} className="todo-form">
          <input
            type="text"
            value={newTodo}
            onChange={(e) => setNewTodo(e.target.value)}
            placeholder="새 할일을 입력하세요..."
            className="todo-input"
          />
          <button type="submit" className="add-button">추가</button>
        </form>
        
        {loading ? (
          <div className="loading">로딩 중...</div>
        ) : (
          <TodoList 
            todos={todos} 
            onToggle={toggleTodo}
            onDelete={deleteTodo}
          />
        )}
      </header>
    </div>
  );
}

export default App;
EOF

cat > src/components/TodoList.js << 'EOF'
import React from 'react';

const TodoList = ({ todos, onToggle, onDelete }) => {
  if (!todos || todos.length === 0) {
    return <div className="no-todos">할일이 없습니다.</div>;
  }

  return (
    <div className="todo-list">
      {todos.map(todo => (
        <div key={todo.id} className={`todo-item ${todo.completed ? 'completed' : ''}`}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => onToggle(todo.id, todo.completed)}
          />
          <span className="todo-title">{todo.title}</span>
          <button 
            onClick={() => onDelete(todo.id)}
            className="delete-button"
          >
            삭제
          </button>
        </div>
      ))}
    </div>
  );
};

export default TodoList;
EOF

cat > src/App.css << 'EOF'
.App {
  text-align: center;
  padding: 20px;
  max-width: 800px;
  margin: 0 auto;
}

.App-header {
  background-color: #f5f5f5;
  padding: 20px;
  border-radius: 10px;
}

.todo-form {
  margin: 20px 0;
  display: flex;
  gap: 10px;
  justify-content: center;
}

.todo-input {
  flex: 1;
  max-width: 300px;
  padding: 10px;
  border: 2px solid #ddd;
  border-radius: 5px;
  font-size: 16px;
}

.add-button {
  padding: 10px 20px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
}

.add-button:hover {
  background-color: #0056b3;
}

.todo-list {
  margin-top: 20px;
}

.todo-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px;
  margin: 5px 0;
  background-color: white;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.todo-item.completed .todo-title {
  text-decoration: line-through;
  color: #666;
}

.todo-title {
  flex: 1;
  text-align: left;
}

.delete-button {
  padding: 5px 10px;
  background-color: #dc3545;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
}

.delete-button:hover {
  background-color: #c82333;
}

.loading, .no-todos {
  padding: 20px;
  color: #666;
  font-style: italic;
}
EOF

# React Dockerfile
cat > Dockerfile << 'EOF'
# syntax=docker/dockerfile:1

# === 빌드 스테이지 ===
FROM node:20-alpine AS build

WORKDIR /app

# 의존성 설치
COPY package*.json ./
RUN npm ci --silent

# 소스 코드 복사 및 빌드
COPY . .
RUN npm run build

# === 프로덕션 스테이지 ===
FROM nginx:alpine AS production

# 빌드된 정적 파일 복사
COPY --from=build /app/build /usr/share/nginx/html

# Nginx 설정 (SPA 라우팅 지원)
RUN echo 'server { \
    listen 80; \
    location / { \
        root /usr/share/nginx/html; \
        index index.html index.htm; \
        try_files $uri $uri/ /index.html; \
    } \
    location /api/ { \
        proxy_pass http://backend:3001; \
        proxy_set_header Host $host; \
        proxy_set_header X-Real-IP $remote_addr; \
    } \
}' > /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
EOF

cd .. # 프로젝트 루트로 돌아가기
```

### 백엔드 API 서버 (Express)

```bash
# 백엔드 설정 (backend 디렉토리)
cd backend

# 이전에 만든 Express 서버 코드를 복사하되 포트를 3001로 변경
cp ../nodejs-docker-express/package.json .
cp ../nodejs-docker-express/server.js .

# 포트 변경
sed -i 's/PORT || 3000/PORT || 3001/g' server.js

# 백엔드 Dockerfile
cat > Dockerfile << 'EOF'
FROM node:20-alpine AS production

# 보안 패키지 설치
RUN apk add --no-cache dumb-init curl

WORKDIR /app

# 보안 사용자 생성
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# 의존성 설치
COPY package*.json ./
RUN npm ci --only=production --silent && npm cache clean --force

# 애플리케이션 코드 복사
COPY --chown=nodejs:nodejs server.js ./

USER nodejs

ENV NODE_ENV=production PORT=3001

HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:3001/health || exit 1

EXPOSE 3001

ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "server.js"]
EOF

cd .. # 프로젝트 루트로
```

### Docker Compose로 풀스택 앱 실행

```bash
# docker-compose.yml 생성
cat > docker-compose.yml << 'EOF'
version: '3.8'

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: todo-backend
    environment:
      - NODE_ENV=production
      - PORT=3001
    ports:
      - "3001:3001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    networks:
      - app-network

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: todo-frontend
    ports:
      - "3000:80"
    depends_on:
      backend:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  node_modules_cache:
EOF

# 개발용 Docker Compose
cat > docker-compose.dev.yml << 'EOF'
version: '3.8'

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: todo-backend-dev
    environment:
      - NODE_ENV=development
      - PORT=3001
    ports:
      - "3001:3001"
    volumes:
      - ./backend:/app
      - backend_node_modules:/app/node_modules
    command: npm run dev
    networks:
      - app-network

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    container_name: todo-frontend-dev
    environment:
      - REACT_APP_API_URL=http://localhost:3001
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
      - frontend_node_modules:/app/node_modules
    command: npm start
    depends_on:
      - backend
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  backend_node_modules:
  frontend_node_modules:
EOF

# 개발용 React Dockerfile
cat > frontend/Dockerfile.dev << 'EOF'
FROM node:20-alpine

WORKDIR /app

RUN apk add --no-cache git

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "start"]
EOF

echo "풀스택 애플리케이션 준비 완료!"
```

## 실습 3: Next.js 애플리케이션 최적화

### Next.js 프로젝트 설정

```bash
mkdir nextjs-docker-demo
cd nextjs-docker-demo

# Next.js package.json
cat > package.json << 'EOF'
{
  "name": "nextjs-docker-demo",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "export": "next export"
  },
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "eslint": "^8.55.0",
    "eslint-config-next": "^14.0.0"
  }
}
EOF

# Next.js 설정
cat > next.config.js << 'EOF'
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  output: 'standalone',
  
  // 환경별 설정
  env: {
    BUILD_TIME: new Date().toISOString(),
  },
  
  // 이미지 최적화 (Docker에서 중요)
  images: {
    unoptimized: false,
    domains: ['localhost'],
  },
  
  // 성능 최적화
  experimental: {
    outputFileTracingRoot: __dirname,
  },
}

module.exports = nextConfig
EOF

# 페이지 컴포넌트들 생성
mkdir -p pages/api app

cat > pages/_app.js << 'EOF'
import '../styles/globals.css'

function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />
}

export default MyApp
EOF

cat > pages/index.js << 'EOF'
import { useState, useEffect } from 'react'
import Head from 'next/head'

export default function Home() {
  const [buildInfo, setBuildInfo] = useState(null)
  const [todos, setTodos] = useState([])
  const [newTodo, setNewTodo] = useState('')

  useEffect(() => {
    fetchBuildInfo()
    fetchTodos()
  }, [])

  const fetchBuildInfo = async () => {
    try {
      const response = await fetch('/api/info')
      const data = await response.json()
      setBuildInfo(data)
    } catch (error) {
      console.error('빌드 정보 조회 실패:', error)
    }
  }

  const fetchTodos = async () => {
    try {
      const response = await fetch('/api/todos')
      const data = await response.json()
      setTodos(data)
    } catch (error) {
      console.error('할일 조회 실패:', error)
    }
  }

  const addTodo = async (e) => {
    e.preventDefault()
    if (!newTodo.trim()) return

    try {
      const response = await fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title: newTodo })
      })
      
      if (response.ok) {
        setNewTodo('')
        fetchTodos()
      }
    } catch (error) {
      console.error('할일 추가 실패:', error)
    }
  }

  return (
    <div>
      <Head>
        <title>Next.js Docker 데모</title>
        <meta name="description" content="Docker로 배포된 Next.js 애플리케이션" />
      </Head>

      <main className="container">
        <h1>Docker Next.js 애플리케이션</h1>
        
        {buildInfo && (
          <div className="build-info">
            <h2>빌드 정보</h2>
            <pre>{JSON.stringify(buildInfo, null, 2)}</pre>
          </div>
        )}
        
        <div className="todo-section">
          <h2>할일 관리</h2>
          
          <form onSubmit={addTodo} className="todo-form">
            <input
              type="text"
              value={newTodo}
              onChange={(e) => setNewTodo(e.target.value)}
              placeholder="새 할일 입력..."
              className="todo-input"
            />
            <button type="submit">추가</button>
          </form>
          
          <div className="todo-list">
            {todos.map(todo => (
              <div key={todo.id} className="todo-item">
                <span>{todo.title}</span>
                <span className="todo-date">
                  {new Date(todo.createdAt).toLocaleString('ko-KR')}
                </span>
              </div>
            ))}
          </div>
        </div>
      </main>
    </div>
  )
}
EOF

# API 라우트들
cat > pages/api/info.js << 'EOF'
export default function handler(req, res) {
  const buildInfo = {
    buildTime: process.env.BUILD_TIME,
    nodeVersion: process.version,
    platform: process.platform,
    arch: process.arch,
    nextVersion: require('next/package.json').version,
    environment: process.env.NODE_ENV,
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    timestamp: new Date().toISOString()
  }
  
  res.status(200).json(buildInfo)
}
EOF

cat > pages/api/todos/index.js << 'EOF'
let todos = [
  { id: 1, title: 'Next.js 학습하기', createdAt: new Date() },
  { id: 2, title: 'Docker 최적화', createdAt: new Date() }
]
let nextId = 3

export default function handler(req, res) {
  if (req.method === 'GET') {
    res.status(200).json(todos)
  } else if (req.method === 'POST') {
    const { title } = req.body
    
    if (!title) {
      return res.status(400).json({ error: 'Title is required' })
    }
    
    const newTodo = {
      id: nextId++,
      title,
      createdAt: new Date()
    }
    
    todos.push(newTodo)
    res.status(201).json(newTodo)
  } else {
    res.setHeader('Allow', ['GET', 'POST'])
    res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}
EOF

# 스타일 파일
mkdir styles
cat > styles/globals.css << 'EOF'
* {
  padding: 0;
  margin: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  color: white;
}

.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

h1 {
  text-align: center;
  margin-bottom: 30px;
  font-size: 2.5em;
}

h2 {
  margin: 20px 0 10px;
  color: #f0f0f0;
}

.build-info {
  background: rgba(255,255,255,0.1);
  padding: 15px;
  border-radius: 10px;
  margin: 20px 0;
  backdrop-filter: blur(10px);
}

.build-info pre {
  font-size: 12px;
  overflow-x: auto;
}

.todo-section {
  background: rgba(255,255,255,0.1);
  padding: 20px;
  border-radius: 10px;
  backdrop-filter: blur(10px);
}

.todo-form {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.todo-input {
  flex: 1;
  padding: 10px;
  border: none;
  border-radius: 5px;
  font-size: 16px;
}

.todo-form button {
  padding: 10px 20px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
}

.todo-form button:hover {
  background-color: #0056b3;
}

.todo-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.todo-item {
  background: rgba(255,255,255,0.2);
  padding: 15px;
  border-radius: 8px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.todo-date {
  font-size: 12px;
  color: #ddd;
}
EOF

echo "Next.js 프로젝트 준비 완료!"
```

### Next.js 최적화된 Dockerfile

```dockerfile
# syntax=docker/dockerfile:1

# === 베이스 이미지 ===
FROM node:20-alpine AS base

# 필수 시스템 패키지 설치
RUN apk add --no-cache libc6-compat curl
WORKDIR /app

# === 의존성 설치 스테이지 ===
FROM base AS deps

# 의존성 파일들 복사
COPY package*.json ./

# 의존성 설치
RUN npm ci --omit=dev --silent && npm cache clean --force

# === 빌드 스테이지 ===
FROM base AS builder

WORKDIR /app

# 모든 의존성 설치 (개발 의존성 포함)
COPY package*.json ./
RUN npm ci --silent

# 소스 코드 복사
COPY . .

# Next.js 빌드 (standalone 모드)
ENV NEXT_TELEMETRY_DISABLED 1
RUN npm run build

# === 프로덕션 스테이지 ===
FROM base AS runner

WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

# 보안 사용자 생성
RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 nextjs

# 필요한 파일들만 복사
COPY --from=builder /app/public ./public

# standalone 빌드 결과물 복사
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

# 헬스체크 설정
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:3000/api/info || exit 1

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
```

## 고급 최적화 기법

### 1. PM2를 사용한 프로덕션 클러스터링

```bash
# PM2 설정 추가
npm install --save pm2

# ecosystem.config.js 생성
cat > ecosystem.config.js << 'EOF'
module.exports = {
  apps: [{
    name: 'node-app',
    script: './server.js',
    instances: 'max', // CPU 코어 수만큼 인스턴스 생성
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'production',
      PORT: 3000
    },
    error_file: './logs/err.log',
    out_file: './logs/out.log',
    log_file: './logs/combined.log',
    time: true,
    
    // 자동 재시작 설정
    autorestart: true,
    watch: false,
    max_memory_restart: '500M',
    
    // 성능 모니터링
    pmx: true,
    
    // Graceful shutdown
    kill_timeout: 5000,
    wait_ready: true,
    listen_timeout: 10000
  }]
}
EOF

# PM2용 Dockerfile 수정
cat > Dockerfile.pm2 << 'EOF'
FROM node:20-alpine AS production

RUN apk add --no-cache dumb-init curl

WORKDIR /app

# 보안 사용자 생성
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# 로그 디렉토리 생성
RUN mkdir -p logs && chown -R nodejs:nodejs logs

# 의존성 설치
COPY package*.json ./
RUN npm ci --only=production --silent && \
    npm install pm2 -g && \
    npm cache clean --force

# 애플리케이션 파일 복사
COPY --chown=nodejs:nodejs server.js ecosystem.config.js ./

USER nodejs

ENV NODE_ENV=production PORT=3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=15s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

EXPOSE 3000

# PM2로 클러스터 모드 실행
CMD ["pm2-runtime", "start", "ecosystem.config.js"]
EOF
```

### 2. 보안 강화된 Dockerfile

```dockerfile
# 보안 최적화 Dockerfile
FROM node:20-alpine AS security-hardened

# 보안 패키지 설치 및 시스템 업데이트
RUN apk upgrade --no-cache && \
    apk add --no-cache \
    dumb-init \
    curl \
    ca-certificates \
    && rm -rf /var/cache/apk/*

WORKDIR /app

# 보안 사용자 생성 (더 강화된 설정)
RUN addgroup -g 1001 -S appgroup && \
    adduser -S appuser -u 1001 -G appgroup && \
    mkdir -p /app/logs && \
    chown -R appuser:appgroup /app && \
    chmod -R 755 /app

# 의존성 설치
COPY --chown=appuser:appgroup package*.json ./
RUN npm ci --only=production --silent && \
    npm audit fix --audit-level moderate && \
    npm cache clean --force

# 애플리케이션 파일 복사
COPY --chown=appuser:appgroup server.js ./

# 파일 권한 설정
RUN chmod 644 server.js

# 사용자 전환
USER appuser

# 보안 환경 변수
ENV NODE_ENV=production \
    PORT=3000 \
    NPM_CONFIG_LOGLEVEL=warn \
    NODE_OPTIONS="--max-old-space-size=512"

# 읽기 전용 루트 파일시스템을 위한 임시 디렉토리
VOLUME ["/tmp", "/app/logs"]

HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

EXPOSE 3000

# dumb-init으로 좀비 프로세스 방지
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "server.js"]
```

### 3. 성능 모니터링 통합

```bash
# 성능 모니터링을 위한 Docker Compose 확장
cat > docker-compose.monitoring.yml << 'EOF'
version: '3.8'

services:
  app:
    build: .
    container_name: node-app
    environment:
      - NODE_ENV=production
    ports:
      - "3000:3000"
    networks:
      - app-network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # 성능 모니터링
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    networks:
      - app-network

  # 메트릭 시각화
  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin123
    volumes:
      - grafana-storage:/var/lib/grafana
    networks:
      - app-network

  # 로그 수집
  loki:
    image: grafana/loki:latest
    container_name: loki
    ports:
      - "3100:3100"
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  grafana-storage:
EOF

# Prometheus 설정
mkdir -p monitoring
cat > monitoring/prometheus.yml << 'EOF'
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'node-app'
    static_configs:
      - targets: ['app:3000']
    metrics_path: '/metrics'
    scrape_interval: 5s
EOF
```

## Node.js Docker 최적화 체크리스트

### 필수 최적화 항목

#### 빌드 최적화
- [ ] 멀티 스테이지 빌드 사용
- [ ] Alpine Linux 베이스 이미지 사용  
- [ ] package.json 우선 복사 (캐시 활용)
- [ ] .dockerignore로 불필요 파일 제외
- [ ] npm ci 사용 (package-lock.json 활용)

#### 런타임 최적화
- [ ] PM2 클러스터 모드 (멀티 코어 활용)
- [ ] 적절한 메모리 제한 설정
- [ ] Graceful shutdown 구현
- [ ] 헬스체크 엔드포인트 구현

#### 보안 강화
- [ ] Non-root 사용자 사용
- [ ] npm audit로 취약점 검사
- [ ] dumb-init으로 시그널 처리 개선
- [ ] 읽기 전용 파일시스템 고려

#### 모니터링 및 로깅
- [ ] 구조화된 로깅 구현
- [ ] 성능 메트릭 수집
- [ ] 에러 추적 시스템 연동
- [ ] 로그 로테이션 설정

## 요약

### 핵심 성과 지표

Node.js 애플리케이션 Docker 최적화로 달성 가능한 성과:

- **이미지 크기**: 1.2GB → 80MB (93% 감소)
- **빌드 시간**: 3분 → 45초 (75% 단축)  
- **시작 시간**: 15초 → 5초 (67% 개선)
- **메모리 사용**: 512MB → 256MB (50% 절약)
- **처리량**: PM2 클러스터로 4배 향상

### 다음 단계

이제 Go 언어 애플리케이션의 극한 최적화를 학습하겠습니다! Go의 정적 컴파일 특성을 활용하면 5MB 미만의 초경량 이미지도 만들 수 있습니다.