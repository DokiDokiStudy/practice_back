---
title: "4.6 연습 문제"
categoryPath:
  - "Docker"
  - "4장 애플리케이션 소스 코드에서 도커 이미지까지"
  - "4.6 연습 문제"
authorNick: "관리자"
createdAt: "2025-08-27"
updateMode: "upsert"
---

# 4.6 최종 보스전 - 연습 문제!

드디어 4장의 마지막 단계입니다!

지금까지 Java, Node.js, Go, 멀티 스테이지까지 모든 것을 배웠으니, 이제 실력을 종합해서 테스트해볼 시간이에요!

**미션**: 최적화가 전혀 되지 않은 Go 웹서버를 받고, 여러분이 직접 Docker 마스터의 실력을 보여주는 거예요! 

준비되셨나요? 함께 도전해봅시다!

## 미션 브리핑

### 문제 1: 현재 상황 파악 및 최적화

**현재 상황**: 최적화가 전혀 안 된 Go 웹서버 Dockerfile이 있어요
**미션**: 이 Dockerfile을 최적화해서 새로운 이미지를 만드세요!

### 문제 2: 이미지 크기 폭탄 해체

**현재 상황**: 
- 리눅스: 800MB 폭탄
- 윈도우: 5.2GB 초대형 폭탄

**미션**: 
- 리눅스: 15MB 이하로 줄이세요! (98% 감소)
- 윈도우: 260MB 이하로 줄이세요! (95% 감소)

### 문제 3: 빌드 캐시 최적화 마스터하기

**현재 상황**: HTML 파일 한 줄만 바꿔도 7단계 전부 다시 빌드
**미션**: HTML 파일을 바꿔도 1단계만 재빌드되도록 최적화하세요!

## 힌트 및 전략 가이드

**지금까지 배운 모든 기술을 활용하세요!**

이번 문제는 여러분이 직접 풀어보셔야 해요. 왜냐하면 Dockerfile 최적화는 실무에서 정말 중요한 기술이거든요!

**힌트**: 지금까지 배운 Go 섹션의 내용을 잘 활용해보세요
- 4.4 Go 섹션에서 배운 모든 기법들이 도움이 될 거예요!
- 멀티 스테이지, 정적 컴파일, Alpine Linux, Scratch 이미지...

**참고 자료**: 답안이 꼭 필요하다면 GitHub 저장소 `ch04/lab/` 폴더에서 확인할 수 있지만, 먼저 스스로 도전해보세요!

---

## 실습 가이드

### 1단계: 현재 상태 확인

```bash
# 현재 디렉터리 이동
cd ch04/lab

# 파일 구조 확인
ls -la

# Dockerfile 내용 확인
cat Dockerfile

# 현재 이미지 빌드
docker build -t lab-app:before .

# 이미지 크기 확인
docker images lab-app:before
```

### 2단계: 최적화 전략 수립

현재 Dockerfile을 분석하고 다음 최적화 기법들을 적용해보자:

#### 이미지 크기 최적화
- 멀티 스테이지 빌드 적용
- 경량 베이스 이미지 사용 (alpine)
- 불필요한 파일 제거
- Go 바이너리 정적 링크

#### 빌드 캐시 최적화  
- 자주 변경되지 않는 레이어를 먼저 배치
- 소스 코드와 의존성 분리
- HTML 파일을 별도 레이어로 관리

### 3단계: 최적화된 Dockerfile 작성

```dockerfile
# 최적화 예시 (실제 답안은 직접 작성해보세요!)

# 빌드 스테이지
FROM golang:alpine AS builder
WORKDIR /app

# Go 모듈 파일만 먼저 복사 (캐시 최적화)
COPY go.mod go.sum ./
RUN go mod download

# 소스 코드 복사 및 빌드
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o main .

# 프로덕션 스테이지  
FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

# 빌드된 바이너리만 복사
COPY --from=builder /app/main .

# HTML 파일은 별도로 복사 (캐시 최적화)
COPY static/ ./static/

CMD ["./main"]
```

### 4단계: 결과 검증

```bash
# 최적화된 이미지 빌드
docker build -t lab-app:after .

# 크기 비교
docker images | grep lab-app

# 기능 테스트
docker run -p 8080:8080 lab-app:after

# HTML 파일 수정 후 재빌드 테스트
echo "수정된 내용" >> static/index.html
docker build -t lab-app:cache-test .
```

---

## 성공 기준 체크리스트

### 필수 달성 조건들
- [ ] **이미지 크기**: 800MB → 15MB 이하 (98% 감소!)
- [ ] **멀티 스테이지 빌드**: 빌드와 실행 환경 분리
- [ ] **캐시 최적화**: HTML 수정 시 1단계만 재빌드
- [ ] **애플리케이션 동작**: 기능이 정상 작동해야 함
- [ ] **정적 링크**: Go 바이너리가 독립실행 가능

### 최적화 성과표

| 항목 | 최적화 전 | 목표 | 내 달성도 |
|------|-----------|------|-----------|
| **이미지 크기** | 800MB | 15MB | ___MB |
| **빌드 재수행** | 7단계 | 1단계 | ___단계 |
| **빌드 시간** | ___분 | ___분 | ___분 |
| **시작 시간** | ___초 | ___초 | ___초 |

## 4장 완전 정복 축하드립니다!

여러분이 이 연습 문제까지 완료하셨다면, 정말로 Docker 최적화 마스터가 되신 거예요!

**4장에서 배운 모든 것들**
- **Java**: JDK→JRE 멀티스테이지로 500MB→150MB
- **Node.js**: npm 캐시 활용으로 1.2GB→80MB  
- **Go**: 정적 컴파일로 1.2GB→5MB
- **멀티 스테이지**: 빌드 캐시와 크기 최적화 원리
- **연습 문제**: 실전 최적화 실력 완성!

이제 여러분은 어떤 언어든 Docker로 효율적으로 컨테이너화할 수 있는 실력을 갖추셨습니다! 

다음 장에서는 더 흥미진진한 Docker의 세계가 기다리고 있어요!