---
title: "4.4 애플리케이션 빌드 실전 예제: Go 소스 코드"
categoryPath:
  - "Docker"
  - "4장 애플리케이션 소스 코드에서 도커 이미지까지"
  - "4.4 애플리케이션 빌드 실전 예제: Go 소스 코드"
authorNick: "관리자"
createdAt: "2025-08-27"
updateMode: "upsert"
---

# 4.4 Go 애플리케이션 빌드 실전 예제

Go 언어는 정적 컴파일과 크로스 플랫폼 지원으로 Docker 컨테이너화에 가장 이상적인 언어 중 하나입니다. 이번 섹션에서는 Go의 특성을 활용하여 5MB 미만의 초경량 이미지를 만드는 방법을 학습합니다.

## Go Docker화의 장점

### Go 언어의 특성
- **정적 컴파일**: 모든 의존성이 바이너리에 포함되어 런타임 의존성 제로
- **크로스 컴파일**: 다양한 플랫폼용 바이너리를 한 번에 생성
- **빠른 시작**: JVM 워밍업이나 인터프리터 오버헤드 없음
- **작은 메모리**: 일반적으로 10-50MB로 실행
- **고성능**: 고루틴을 통한 높은 동시성 처리

### 다른 언어와의 비교

| 언어 | 이미지 크기 | 시작 시간 | 메모리 사용 |
|------|------------|----------|-----------|
| **Go** | **5-20MB** | **< 100ms** | **10-50MB** |
| Java | 150-500MB | 2-5초 | 256-512MB |
| Node.js | 80-200MB | 1-3초 | 50-200MB |

## 실습: Go REST API 서버

### 프로젝트 설정

```bash
mkdir go-docker-demo && cd go-docker-demo
go mod init go-docker-demo
```

**go.mod**:
```go
module go-docker-demo

go 1.22

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/gin-contrib/cors v1.5.0
)
```

### Go 애플리케이션 코드

**main.go**:
```go
package main

import (
    "net/http"
    "os"
    "runtime"
    "sync"
    "time"

    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
)

type Todo struct {
    ID          int       `json:"id"`
    Title       string    `json:"title"`
    Description string    `json:"description"`
    Completed   bool      `json:"completed"`
    CreatedAt   time.Time `json:"created_at"`
}

type TodoManager struct {
    todos     []Todo
    mutex     sync.RWMutex
    idCounter int
}

func NewTodoManager() *TodoManager {
    return &TodoManager{
        todos: []Todo{
            {
                ID:        1,
                Title:     "Go 학습하기",
                Completed: false,
                CreatedAt: time.Now(),
            },
            {
                ID:        2,
                Title:     "Docker 최적화",
                Completed: true,
                CreatedAt: time.Now(),
            },
        },
        idCounter: 2,
    }
}

func (tm *TodoManager) GetAll() []Todo {
    tm.mutex.RLock()
    defer tm.mutex.RUnlock()
    return tm.todos
}

func (tm *TodoManager) Create(title, description string) *Todo {
    tm.mutex.Lock()
    defer tm.mutex.Unlock()
    
    tm.idCounter++
    todo := Todo{
        ID:          tm.idCounter,
        Title:       title,
        Description: description,
        Completed:   false,
        CreatedAt:   time.Now(),
    }
    
    tm.todos = append(tm.todos, todo)
    return &todo
}

var (
    startTime   = time.Now()
    todoManager = NewTodoManager()
)

func main() {
    gin.SetMode(gin.ReleaseMode)
    router := gin.Default()
    
    // CORS 설정
    router.Use(cors.Default())
    
    // 라우트 설정
    router.GET("/", getServerInfo)
    router.GET("/health", getHealth)
    router.GET("/api/todos", getTodos)
    router.POST("/api/todos", createTodo)
    
    port := getEnvOrDefault("PORT", "8080")
    router.Run(":" + port)
}

func getServerInfo(c *gin.Context) {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    c.JSON(http.StatusOK, gin.H{
        "message":     "Docker로 배포된 Go API 서버",
        "go_version":  runtime.Version(),
        "platform":    runtime.GOOS + "/" + runtime.GOARCH,
        "uptime":      time.Since(startTime).String(),
        "memory_mb":   m.Alloc / 1024 / 1024,
        "goroutines":  runtime.NumGoroutine(),
        "timestamp":   time.Now(),
    })
}

func getHealth(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        "status":    "healthy",
        "timestamp": time.Now(),
        "uptime":    time.Since(startTime).String(),
    })
}

func getTodos(c *gin.Context) {
    todos := todoManager.GetAll()
    c.JSON(http.StatusOK, gin.H{
        "todos":     todos,
        "total":     len(todos),
        "timestamp": time.Now(),
    })
}

func createTodo(c *gin.Context) {
    var req struct {
        Title       string `json:"title" binding:"required"`
        Description string `json:"description"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": err.Error(),
        })
        return
    }
    
    todo := todoManager.Create(req.Title, req.Description)
    c.JSON(http.StatusCreated, gin.H{
        "todo": todo,
    })
}

func getEnvOrDefault(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}
```

## Docker 이미지 최적화

### 비효율적인 Dockerfile

```dockerfile
# 문제가 많은 접근법
FROM golang:1.22

WORKDIR /app
COPY . .
RUN go build -o main .

EXPOSE 8080
CMD ["./main"]
```

**문제점**:
- 빌드 도구까지 런타임에 포함 (1.2GB)
- Go의 정적 컴파일 장점 미활용
- 보안 취약점 존재

### 최적화 레벨 1: 멀티 스테이지 빌드

```dockerfile
# === 빌드 스테이지 ===
FROM golang:1.22-alpine AS builder
WORKDIR /app

# Go 모듈 파일 먼저 복사 (캐시 최적화)
COPY go.mod go.sum ./
RUN go mod download

# 소스 코드 복사 및 빌드
COPY . .
RUN go build -o main .

# === 프로덕션 스테이지 ===
FROM alpine:latest AS production

RUN apk --no-cache add ca-certificates
WORKDIR /root/

# 빌드된 바이너리만 복사
COPY --from=builder /app/main .

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD wget --spider --quiet http://localhost:8080/health || exit 1

EXPOSE 8080
CMD ["./main"]
```

**결과**: 1.2GB → 15MB (99% 감소)

### 최적화 레벨 2: 정적 바이너리 + Distroless

```dockerfile
# === 빌드 스테이지 ===
FROM golang:1.22-alpine AS builder
WORKDIR /app

# 빌드 도구 설치
RUN apk add --no-cache git ca-certificates tzdata

# Go 모듈 의존성 설치
COPY go.mod go.sum ./
RUN go mod download

# 소스 코드 복사
COPY . .

# 정적 링크 바이너리 빌드
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags='-w -s -extldflags "-static"' \
    -a -installsuffix cgo \
    -o main .

# === 프로덕션 스테이지 ===
FROM gcr.io/distroless/static:nonroot

# 빌드된 바이너리 복사
COPY --from=builder /app/main /

USER nonroot:nonroot
EXPOSE 8080
ENTRYPOINT ["/main"]
```

**결과**: 15MB → 8MB (추가 47% 감소)

### 최적화 레벨 3: Scratch 베이스 (극한 최적화)

```dockerfile
# === 빌드 스테이지 ===
FROM golang:1.22-alpine AS builder
WORKDIR /app

# SSL 인증서 및 시간대 정보 준비
RUN apk add --no-cache ca-certificates tzdata

# 의존성 설치
COPY go.mod go.sum ./
RUN go mod download

# 소스 코드 복사
COPY . .

# 완전 정적 바이너리 빌드
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags='-w -s -extldflags "-static"' \
    -tags netgo -a -installsuffix netgo \
    -o main .

# === 최종 스테이지 (Scratch) ===
FROM scratch

# 필수 파일들만 복사
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo

# 애플리케이션 바이너리
COPY --from=builder /app/main /main

EXPOSE 8080
ENTRYPOINT ["/main"]
```

**결과**: 8MB → 5MB (극한 최적화)

## 고급 최적화 기법

### 크로스 컴파일 활용

```bash
# 멀티 플랫폼 빌드 스크립트
#!/bin/bash

PLATFORMS=(
    "linux/amd64"
    "linux/arm64"
    "darwin/amd64"
    "windows/amd64"
)

for platform in "${PLATFORMS[@]}"; do
    IFS="/" read -r os arch <<< "$platform"
    
    output_name="go-app-$os-$arch"
    if [ "$os" = "windows" ]; then
        output_name="${output_name}.exe"
    fi
    
    env GOOS=$os GOARCH=$arch CGO_ENABLED=0 go build \
        -ldflags="-w -s" \
        -o "dist/$output_name" .
        
    echo "Built: $output_name"
done
```

### Docker Buildx 멀티 플랫폼

```bash
# Docker 멀티 플랫폼 빌드
docker buildx build \
    --platform linux/amd64,linux/arm64 \
    --tag go-app:latest \
    --push .
```

### 고급 빌드 옵션 Dockerfile

```dockerfile
# 고급 최적화 Dockerfile
FROM golang:1.22-alpine AS builder

ARG CGO_ENABLED=0
ARG GOOS=linux
ARG GOARCH=amd64

WORKDIR /app

# 빌드 도구 설치
RUN apk add --no-cache ca-certificates tzdata git upx

# Go 빌드 캐시 활용
COPY go.mod go.sum ./
RUN --mount=type=cache,target=/go/pkg/mod \
    go mod download

COPY . .

# 최적화된 빌드
RUN --mount=type=cache,target=/go/pkg/mod \
    --mount=type=cache,target=/root/.cache/go-build \
    CGO_ENABLED=${CGO_ENABLED} GOOS=${GOOS} GOARCH=${GOARCH} \
    go build -ldflags='-w -s' -o main .

# UPX로 바이너리 압축
RUN upx --best main

FROM scratch AS production

COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=builder /app/main /main

EXPOSE 8080
ENTRYPOINT ["/main"]
```

## 성능 테스트

### 부하 테스트 스크립트

```bash
#!/bin/bash
SERVER_URL=${1:-"http://localhost:8080"}

echo "Go 서버 부하 테스트"
echo "서버 URL: $SERVER_URL"

# 헬스체크
curl -f $SERVER_URL/health

# ApacheBench 테스트
if command -v ab > /dev/null; then
    echo "ApacheBench 결과:"
    ab -n 1000 -c 10 $SERVER_URL/
fi

# 메모리 사용량 확인
curl -s $SERVER_URL/ | jq '.memory_mb'
```

## Docker Compose 전체 스택

```yaml
version: '3.8'

services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: go-api
    environment:
      - PORT=8080
    ports:
      - "8080:8080"
    healthcheck:
      test: ["CMD", "wget", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 64M
          cpus: '0.5'
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      api:
        condition: service_healthy
```

## Go Docker 최적화 체크리스트

### 빌드 최적화
- [ ] 멀티 스테이지 빌드 사용
- [ ] CGO_ENABLED=0으로 정적 빌드
- [ ] -ldflags='-w -s' 디버그 정보 제거
- [ ] Go 모듈 캐시 활용
- [ ] UPX 압축 (선택사항)

### 이미지 최적화
- [ ] Scratch 또는 Distroless 베이스 이미지
- [ ] 필수 시스템 파일만 복사
- [ ] 멀티 플랫폼 빌드 지원
- [ ] 적절한 헬스체크 설정

### 보안 강화
- [ ] 비루트 사용자 실행
- [ ] 읽기 전용 파일시스템
- [ ] 최소 권한 원칙
- [ ] 보안 스캔 도구 통합

## 최적화 성과

| 항목 | 최적화 전 | 최적화 후 | 개선율 |
|------|-----------|-----------|--------|
| 이미지 크기 | 1.2GB | 5MB | 99.6% |
| 시작 시간 | 3초 | 0.1초 | 97% |
| 메모리 사용 | 256MB | 15MB | 94% |
| 처리량 | - | 20,000+ RPS | - |

Go 언어의 정적 컴파일 특성을 최대한 활용하면 가장 효율적인 컨테이너 애플리케이션을 구축할 수 있습니다.