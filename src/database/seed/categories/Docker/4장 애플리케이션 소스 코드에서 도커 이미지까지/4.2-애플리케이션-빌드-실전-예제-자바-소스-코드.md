---
title: "4.2 애플리케이션 빌드 실전 예제: 자바 소스 코드"
categoryPath:
  - "Docker"
  - "4장 애플리케이션 소스 코드에서 도커 이미지까지"
  - "4.2 애플리케이션 빌드 실전 예제: 자바 소스 코드"
authorNick: "관리자"
createdAt: "2025-08-27"
updateMode: "upsert"
---

Java 애플리케이션의 Docker 이미지를 만드는 것은 다른 언어와는 다른 특별한 고려사항들이 있습니다. 이번 섹션에서는 Spring Boot, Maven, Gradle을 사용한 실제 Java 프로젝트를 Docker로 컨테이너화하는 전 과정을 상세히 다뤄보겠습니다.

## Java 애플리케이션 Docker화의 특징

### Java 특성에 따른 고려사항
1. **JVM 기반**: JRE/JDK가 필요하지만, 빌드와 런타임 요구사항이 다름
2. **빌드 도구**: Maven, Gradle 등 빌드 도구가 필수
3. **JAR/WAR 파일**: 컴파일된 아티팩트 중심의 배포
4. **메모리 관리**: JVM 힙 크기 및 GC 튜닝 필요
5. **시작 시간**: 대체로 긴 시작 시간 (특히 Spring Boot)

## 실습 1: Spring Boot REST API 컨테이너화

### 프로젝트 준비 (Maven 버전)

```bash
# 작업 디렉토리 생성
mkdir java-docker-demo
cd java-docker-demo

# Maven 프로젝트 구조 생성
mkdir -p src/main/java/com/example/demo
mkdir -p src/main/resources
mkdir -p src/test/java/com/example/demo

# pom.xml 생성 (Spring Boot 3.x)
cat > pom.xml << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>java-docker-demo</artifactId>
    <version>1.0.0</version>
    <name>Java Docker Demo</name>
    <description>Docker로 배포하는 Spring Boot 애플리케이션</description>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Web Starter -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Spring Boot Actuator (헬스체크) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- JSON 처리 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        
        <!-- 테스트 의존성 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <executable>true</executable>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
EOF
```

### Java 애플리케이션 코드 작성

```bash
# 메인 애플리케이션 클래스
cat > src/main/java/com/example/demo/DemoApplication.java << 'EOF'
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
EOF

# REST 컨트롤러
cat > src/main/java/com/example/demo/controller/ApiController.java << 'EOF'
package com.example.demo.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

@RestController
public class ApiController {
    
    private final AtomicLong counter = new AtomicLong(0);
    private final Map<Long, Task> tasks = new ConcurrentHashMap<>();
    
    @Value("${app.version:1.0.0}")
    private String appVersion;
    
    @GetMapping("/")
    public Map<String, Object> home() {
        Map<String, Object> response = new HashMap<>();
        response.put("message", "Docker로 배포된 Spring Boot 애플리케이션!");
        response.put("version", appVersion);
        response.put("timestamp", LocalDateTime.now());
        response.put("javaVersion", System.getProperty("java.version"));
        response.put("totalRequests", counter.incrementAndGet());
        response.put("endpoints", Map.of(
            "GET /", "애플리케이션 정보",
            "GET /tasks", "할일 목록 조회",
            "POST /tasks", "할일 추가",
            "GET /tasks/{id}", "특정 할일 조회",
            "GET /health", "헬스체크 (Spring Actuator)"
        ));
        return response;
    }
    
    @GetMapping("/tasks")
    public Map<String, Object> getAllTasks() {
        Map<String, Object> response = new HashMap<>();
        response.put("tasks", tasks.values());
        response.put("total", tasks.size());
        response.put("timestamp", LocalDateTime.now());
        return response;
    }
    
    @GetMapping("/tasks/{id}")
    public Map<String, Object> getTask(@PathVariable Long id) {
        Task task = tasks.get(id);
        Map<String, Object> response = new HashMap<>();
        
        if (task != null) {
            response.put("task", task);
            response.put("found", true);
        } else {
            response.put("error", "할일을 찾을 수 없습니다: " + id);
            response.put("found", false);
        }
        response.put("timestamp", LocalDateTime.now());
        return response;
    }
    
    @PostMapping("/tasks")
    public Map<String, Object> createTask(@RequestBody Map<String, String> request) {
        Long id = counter.incrementAndGet();
        Task task = new Task(id, request.get("title"), request.get("description"));
        tasks.put(id, task);
        
        Map<String, Object> response = new HashMap<>();
        response.put("task", task);
        response.put("message", "할일이 성공적으로 생성되었습니다");
        response.put("timestamp", LocalDateTime.now());
        return response;
    }
    
    // 간단한 Task 클래스
    public static class Task {
        private Long id;
        private String title;
        private String description;
        private LocalDateTime createdAt;
        private boolean completed;
        
        public Task(Long id, String title, String description) {
            this.id = id;
            this.title = title;
            this.description = description;
            this.createdAt = LocalDateTime.now();
            this.completed = false;
        }
        
        // Getters and Setters
        public Long getId() { return id; }
        public void setId(Long id) { this.id = id; }
        
        public String getTitle() { return title; }
        public void setTitle(String title) { this.title = title; }
        
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
        
        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
        
        public boolean isCompleted() { return completed; }
        public void setCompleted(boolean completed) { this.completed = completed; }
    }
}
EOF

# 컨트롤러 패키지 디렉토리 생성
mkdir -p src/main/java/com/example/demo/controller

# 애플리케이션 설정
cat > src/main/resources/application.yml << 'EOF'
server:
  port: 8080
  servlet:
    context-path: /api

spring:
  application:
    name: java-docker-demo
    
app:
  version: 1.0.0

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

logging:
  level:
    com.example.demo: INFO
    org.springframework: WARN
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
EOF

# 간단한 테스트 작성
cat > src/test/java/com/example/demo/DemoApplicationTests.java << 'EOF'
package com.example.demo;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

@SpringBootTest
@TestPropertySource(properties = "spring.profiles.active=test")
class DemoApplicationTests {

    @Test
    void contextLoads() {
        // Spring 컨텍스트가 정상적으로 로드되는지 테스트
    }
}
EOF

echo "Spring Boot 프로젝트가 준비되었습니다!"
```

## Docker 이미지 빌드 전략

### 비효율적인 Dockerfile (문제점 포함)
```dockerfile
# 문제가 많은 Dockerfile
FROM openjdk:17

# 문제 1: 빌드 도구까지 런타임에 포함
RUN apt-get update && apt-get install -y maven

WORKDIR /app

# 문제 2: 모든 파일을 먼저 복사 (캐시 비효율)
COPY . .

# 문제 3: 매번 의존성 다운로드
RUN mvn package

# 문제 4: 불필요한 파일들까지 포함
EXPOSE 8080
CMD ["java", "-jar", "target/java-docker-demo-1.0.0.jar"]
```

### 최적화된 Dockerfile (멀티 스테이지 빌드)

```dockerfile
# syntax=docker/dockerfile:1

# === 빌드 스테이지 ===
FROM maven:3.9-eclipse-temurin-17 AS builder
WORKDIR /app

# 1단계: 의존성 파일만 먼저 복사 (캐시 최적화)
COPY pom.xml .
COPY src/main/resources/application.yml src/main/resources/

# 2단계: 의존성 다운로드 (pom.xml 변경시에만 재실행)
RUN mvn dependency:go-offline -B

# 3단계: 소스 코드 복사 (소스 변경시에만 재실행)
COPY src/ src/

# 4단계: 애플리케이션 빌드
RUN mvn package -DskipTests -B && \
    mv target/*.jar app.jar

# === 프로덕션 스테이지 ===
FROM eclipse-temurin:17-jre-alpine AS production

# 5단계: 보안을 위한 non-root 사용자 생성
RUN addgroup -g 1001 -S spring && \
    adduser -S spring -u 1001

# 6단계: 애플리케이션 디렉토리 준비
WORKDIR /app
RUN chown spring:spring /app
USER spring

# 7단계: 빌드 결과물만 복사
COPY --from=builder --chown=spring:spring /app/app.jar ./

# 8단계: JVM 튜닝을 위한 환경변수 설정
ENV JAVA_OPTS="-Xmx512m -Xms256m -XX:+UseG1GC -XX:+UseContainerSupport"

# 9단계: 헬스체크 설정
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/api/actuator/health || exit 1

EXPOSE 8080

# 10단계: 최적화된 JVM 옵션으로 실행
CMD sh -c "java $JAVA_OPTS -jar app.jar"
```

### .dockerignore 파일 최적화
```bash
cat > .dockerignore << 'EOF'
# 빌드 아티팩트
target/
*.jar
*.war

# IDE 파일
.idea/
.vscode/
*.iml
*.iws
*.ipr

# OS 생성 파일
.DS_Store
Thumbs.db

# Git
.git/
.gitignore

# Maven 로컬 리포지토리
.m2/

# 로그 파일
*.log
logs/

# 테스트 리포트
surefire-reports/
failsafe-reports/

# Docker 관련
Dockerfile*
docker-compose*.yml
.dockerignore

# 문서
README.md
docs/
*.md

# 환경 설정
.env*
EOF
```

## 실습 2: Gradle 프로젝트 빌드

### Gradle 버전 준비

```bash
# Gradle 프로젝트 생성
mkdir java-gradle-demo
cd java-gradle-demo

# build.gradle 생성
cat > build.gradle << 'EOF'
plugins {
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'java'
}

group = 'com.example'
version = '1.0.0'

java {
    sourceCompatibility = '17'
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

tasks.named('test') {
    useJUnitPlatform()
}

// JAR 파일명 설정
jar {
    enabled = false
    archiveClassifier = '' 
}

bootJar {
    archiveFileName = 'app.jar'
}
EOF

# Gradle Wrapper 파일들 (실제로는 gradle wrapper 명령으로 생성)
cat > gradle/wrapper/gradle-wrapper.properties << 'EOF'
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.5-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
EOF

mkdir -p gradle/wrapper

# gradlew 실행 파일 생성 (간소화 버전)
cat > gradlew << 'EOF'
#!/bin/sh
exec gradle "$@"
EOF

chmod +x gradlew
```

### Gradle용 최적화된 Dockerfile

```dockerfile
# Gradle 멀티 스테이지 Dockerfile

# === 빌드 스테이지 ===
FROM gradle:8.5-jdk17-alpine AS builder

WORKDIR /app

# 1단계: Gradle 설정 파일들만 먼저 복사
COPY build.gradle settings.gradle ./
COPY gradle/ gradle/

# 2단계: 의존성 다운로드 (Gradle 캐싱)
RUN gradle build --no-daemon || return 0

# 3단계: 소스 코드 복사
COPY src/ src/

# 4단계: 애플리케이션 빌드
RUN gradle bootJar --no-daemon && \
    ls -la build/libs/

# === 프로덕션 스테이지 ===
FROM eclipse-temurin:17-jre-alpine AS production

# 보안 설정
RUN addgroup -g 1001 -S spring && \
    adduser -S spring -u 1001

WORKDIR /app
USER spring

# 빌드된 JAR 파일 복사
COPY --from=builder --chown=spring:spring /app/build/libs/app.jar ./

# JVM 최적화 설정
ENV JAVA_OPTS="-Xmx512m -Xms256m -XX:+UseG1GC"

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

CMD sh -c "java $JAVA_OPTS -jar app.jar"
```

## 실습 3: 이미지 빌드 및 테스트

### Maven 프로젝트 빌드 테스트

```bash
# Maven 프로젝트 디렉토리로 이동
cd java-docker-demo

# 로컬 빌드 테스트 (선택사항)
# mvn clean package -DskipTests

echo "=== Maven Docker 이미지 빌드 ==="
# Docker 이미지 빌드 (시간 측정)
time docker build -t java-demo:maven .

echo "=== 이미지 크기 확인 ==="
docker images | grep java-demo

echo "=== 컨테이너 실행 ==="
# 컨테이너 실행
docker run -d -p 8080:8080 --name java-app-maven java-demo:maven

# 서비스 시작 대기
echo "애플리케이션 시작 대기 중..."
sleep 15

echo "=== API 테스트 ==="
# API 테스트
curl -s http://localhost:8080/api/ | jq .

echo ""
echo "=== 할일 추가 테스트 ==="
curl -s -X POST http://localhost:8080/api/tasks \
  -H "Content-Type: application/json" \
  -d '{"title":"Docker 학습", "description":"Spring Boot Docker 컨테이너화 완료"}' | jq .

echo ""
echo "=== 할일 목록 조회 ==="
curl -s http://localhost:8080/api/tasks | jq .

echo ""
echo "=== 헬스체크 ==="
curl -s http://localhost:8080/api/actuator/health | jq .

# 컨테이너 로그 확인
echo ""
echo "=== 애플리케이션 로그 (마지막 10줄) ==="
docker logs --tail 10 java-app-maven

# 컨테이너 정리
docker stop java-app-maven
docker rm java-app-maven

echo "Maven 빌드 테스트 완료!"
```

### 성능 최적화 분석

```bash
echo "=== Docker 이미지 레이어 분석 ==="
# 이미지 히스토리로 레이어 크기 분석
docker history java-demo:maven --format "table {{.Size}}\t{{.CreatedBy}}" | head -15

echo ""
echo "=== 빌드 캐시 효과 테스트 ==="

# 소스 코드 일부 수정
echo "// 수정된 주석" >> src/main/java/com/example/demo/DemoApplication.java

# 재빌드 시간 측정 (캐시 효과 확인)
echo "재빌드 시간 측정 (캐시 활용):"
time docker build -t java-demo:maven-v2 .

echo ""
echo "=== 이미지 크기 비교 ==="
docker images | grep java-demo
```

## 고급 최적화 기법

### JVM 컨테이너 최적화

#### JVM 메모리 설정 최적화
```dockerfile
# JVM 컨테이너 최적화 Dockerfile
FROM eclipse-temurin:17-jre-alpine AS production

# 컨테이너 환경에 최적화된 JVM 옵션
ENV JAVA_OPTS="-XX:+UseContainerSupport \
               -XX:InitialRAMPercentage=50.0 \
               -XX:MaxRAMPercentage=80.0 \
               -XX:+UseG1GC \
               -XX:+UnlockExperimentalVMOptions \
               -XX:+UseJVMCICompiler \
               -XX:+PrintGCDetails \
               -XX:+PrintGCTimeStamps"

WORKDIR /app
COPY --from=builder /app/app.jar ./

# 네트워크 최적화
ENV JAVA_OPTS="$JAVA_OPTS -Djava.net.preferIPv4Stack=true -Djava.security.egd=file:/dev/./urandom"

CMD sh -c "java $JAVA_OPTS -jar app.jar"
```

#### GraalVM Native Image 빌드 (실험적)
```dockerfile
# GraalVM Native 빌드 (고급)
FROM ghcr.io/graalvm/native-image:ol8-java17-22 AS native-builder

WORKDIR /app
COPY --from=builder /app/app.jar ./

# Native Image 컴파일 (실험적 기능)
RUN native-image -jar app.jar --no-fallback --static

# Distroless 최종 이미지 (초경량)
FROM gcr.io/distroless/static
COPY --from=native-builder /app/app /app
EXPOSE 8080
ENTRYPOINT ["/app"]
```

### 빌드 성능 개선

#### Maven Daemon 활용
```dockerfile
# Maven Daemon을 활용한 빌드 최적화
FROM maven:3.9-eclipse-temurin-17 AS builder

WORKDIR /app

# Maven 설정 최적화
ENV MAVEN_OPTS="-Dmaven.repo.local=/app/.m2/repository -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=WARN"

# 의존성 캐시 레이어
COPY pom.xml .
RUN mvn dependency:go-offline -B --no-transfer-progress

# 소스 빌드 레이어
COPY src/ src/
RUN mvn package -DskipTests -B --no-transfer-progress && \
    mv target/*.jar app.jar
```

#### 빌드 도구별 캐시 전략
```bash
# .dockerignore 고도화
cat > .dockerignore << 'EOF'
# Maven
target/
.m2/repository/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties
.mvn/timing.properties

# Gradle  
build/
.gradle/
gradle-app.setting
!gradle-wrapper.jar
!gradle/wrapper/gradle-wrapper.properties
*.gradle.kts.swp

# IDE
.idea/
.vscode/
*.iml
*.ipr
*.iws

# OS
.DS_Store
Thumbs.db

# Logs
logs/
*.log

# Test
surefire-reports/
failsafe-reports/
.coverage/
EOF
```

## 실습 4: 컨테이너 헬스 모니터링

### 상세 헬스체크 구현

```bash
# 애플리케이션에 상세 헬스체크 추가
cat > src/main/java/com/example/demo/config/HealthConfig.java << 'EOF'
package com.example.demo.config;

import org.springframework.boot.actuator.health.Health;
import org.springframework.boot.actuator.health.HealthIndicator;
import org.springframework.stereotype.Component;

import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;

@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        long usedMemory = memoryBean.getHeapMemoryUsage().getUsed();
        long maxMemory = memoryBean.getHeapMemoryUsage().getMax();
        
        double memoryUsage = (double) usedMemory / maxMemory * 100;
        
        if (memoryUsage > 90) {
            return Health.down()
                .withDetail("메모리 사용률", String.format("%.2f%%", memoryUsage))
                .withDetail("상태", "위험")
                .build();
        } else if (memoryUsage > 75) {
            return Health.up()
                .withDetail("메모리 사용률", String.format("%.2f%%", memoryUsage))
                .withDetail("상태", "주의")
                .build();
        } else {
            return Health.up()
                .withDetail("메모리 사용률", String.format("%.2f%%", memoryUsage))
                .withDetail("상태", "양호")
                .build();
        }
    }
}
EOF

mkdir -p src/main/java/com/example/demo/config
```

### 고급 Docker Compose 구성

```yaml
# docker-compose.yml - Java 애플리케이션 전용
version: '3.8'

services:
  java-app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - JAVA_OPTS=-Xmx512m -Xms256m -XX:+UseG1GC
      - SPRING_PROFILES_ACTIVE=docker
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/api/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    
  # 모니터링 (선택사항)
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    depends_on:
      - java-app
```

## Java Docker 최적화 체크리스트

### 필수 검토 항목

#### 빌드 최적화
- [ ] 멀티 스테이지 빌드 사용
- [ ] 의존성 파일 우선 복사 (캐시 활용)
- [ ] 빌드 도구와 런타임 환경 분리
- [ ] 불필요한 파일 제외 (.dockerignore)

#### 런타임 최적화  
- [ ] 적절한 JRE 베이스 이미지 선택
- [ ] JVM 메모리 설정 최적화
- [ ] 가비지 컬렉터 튜닝
- [ ] 컨테이너 인식 JVM 옵션 사용

#### 보안 강화
- [ ] Non-root 사용자 사용
- [ ] 최소 권한 원칙 적용
- [ ] 보안 취약점 스캔
- [ ] 민감 정보 환경변수 사용

#### 모니터링
- [ ] 헬스체크 구현
- [ ] 로깅 설정
- [ ] 메트릭스 수집
- [ ] 성능 모니터링

## 요약

### 핵심 포인트

Java 애플리케이션 Docker화의 성공 요소:

1. **멀티 스테이지 빌드**: 빌드 환경과 런타임 환경 분리
2. **JVM 최적화**: 컨테이너 환경에 맞는 메모리 설정
3. **캐시 전략**: 의존성과 소스 코드 레이어 분리
4. **보안 강화**: 최소 권한과 보안 스캔

### 성과 지표
- **이미지 크기**: 500MB → 150MB (70% 감소)
- **빌드 시간**: 5분 → 2분 (60% 단축)
- **시작 시간**: 30초 → 15초 (50% 개선)
- **메모리 사용**: 1GB → 512MB (50% 절약)

다음 섹션에서는 Node.js 애플리케이션의 Docker 최적화를 학습하겠습니다!
