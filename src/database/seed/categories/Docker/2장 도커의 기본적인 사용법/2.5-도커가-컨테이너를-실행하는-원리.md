---
title: "2.5 도커가 컨테이너를 실행하는 원리"
categoryPath:
  - "Docker"
  - "2장 도커의 기본적인 사용법"
  - "2.5 도커가 컨테이너를 실행하는 원리"
authorNick: "관리자"
createdAt: "2025-08-27"
updateMode: "upsert"
---

Docker는 마법이 아닙니다. 리눅스 커널이 제공하는 기존 기술들을 영리하게 조합하여 컨테이너를 구현합니다. 이번 섹션에서는 Docker의 내부 동작 원리를 이해해보겠습니다.

## Docker 아키텍처 개요

```
┌─────────────────────────────────────────┐
│           Docker Client (CLI)           │
├─────────────────────────────────────────┤
│           Docker Daemon (dockerd)       │
├─────────────────────────────────────────┤
│    containerd (컨테이너 런타임)         │
├─────────────────────────────────────────┤
│         runc (OCI 런타임)               │
├─────────────────────────────────────────┤
│          Linux Kernel                   │
│   ┌─────────────┬─────────────────────┐  │
│   │ Namespaces  │     cgroups         │  │
│   │             │                     │  │
│   │ UnionFS     │  Security Modules   │  │
│   └─────────────┴─────────────────────┘  │
└─────────────────────────────────────────┘
```

## 1. 네임스페이스 (Namespaces) - 격리의 핵심

네임스페이스는 컨테이너가 "독립된 서버"처럼 보이게 하는 핵심 기술입니다.

### PID 네임스페이스 - 프로세스 격리
```bash
# 호스트에서 프로세스 확인
ps aux | head -5

# 컨테이너에서 프로세스 확인
docker run -it ubuntu bash
ps aux  # PID 1부터 시작하는 독립적인 프로세스 공간
```

### 네트워크 네임스페이스 - 네트워크 격리
```bash
# 호스트의 네트워크 인터페이스
ip addr show

# 컨테이너의 네트워크 인터페이스
docker run -it ubuntu bash
apt update && apt install -y iproute2
ip addr show  # 완전히 다른 네트워크 환경
```

## 2. Control Groups (cgroups) - 리소스 제한

cgroups는 컨테이너가 사용할 수 있는 리소스를 제한하고 모니터링합니다.

### 메모리 제한 실습
```bash
# 512MB 메모리 제한
docker run -it -m 512m ubuntu bash

# 리소스 사용량 실시간 확인
docker stats
```

### CPU 제한 실습
```bash
# CPU 1.5개 코어로 제한
docker run -it --cpus="1.5" ubuntu bash
```

## 3. Union File System - 레이어드 파일시스템

Docker 이미지는 여러 레이어로 구성되며, 실행 시 하나의 통합된 파일시스템으로 보입니다.

### 이미지 레이어 구조
```
┌─────────────────────────────────────┐
│     컨테이너 레이어 (읽기/쓰기)     │  ← 새로운 파일, 수정된 파일
├─────────────────────────────────────┤
│       애플리케이션 레이어           │  ← ADD app.jar /app/
├─────────────────────────────────────┤
│         JDK 레이어                  │  ← FROM openjdk:11
├─────────────────────────────────────┤
│       베이스 OS 레이어              │  ← Ubuntu/Alpine 등
└─────────────────────────────────────┘
```

### 레이어 확인 실습
```bash
# 이미지의 레이어 정보 확인
docker history ubuntu

# 상세한 레이어 정보
docker inspect ubuntu
```

## Docker 실행 과정

### `docker run ubuntu bash` 명령어 실행 시 일어나는 일

1. **이미지 준비**: 로컬에서 이미지 검색, 없으면 레지스트리에서 다운로드
2. **네임스페이스 생성**: PID, Network, Mount, UTS, IPC 네임스페이스 생성  
3. **cgroup 설정**: 리소스 제한 cgroup 생성 및 설정
4. **파일시스템 구성**: Union 파일시스템으로 레이어 마운트
5. **프로세스 실행**: 새로운 네임스페이스에서 bash 프로세스 실행

## 컨테이너와 호스트의 관계

### 프로세스 관점에서 보기
```bash
# 호스트에서 컨테이너 프로세스 확인
docker run -d --name test-container nginx
ps aux | grep nginx

# 컨테이너 내부에서는 PID 1
docker exec test-container ps aux
```

## Docker vs 가상머신

이제 내부 원리를 이해했으니, 왜 Docker가 가상머신보다 빠르고 가벼운지 명확해집니다:

### 가상머신
- 하이퍼바이저가 하드웨어를 에뮬레이션
- 각 VM마다 완전한 게스트 OS 필요
- 메모리, CPU 오버헤드 큼

### Docker 컨테이너  
- 호스트 OS 커널을 공유
- 네임스페이스와 cgroup만으로 격리
- 최소한의 오버헤드

## 요약

Docker의 "마법"은 사실 다음과 같은 Linux 커널 기능들의 조합입니다:

**Namespaces**: 격리된 실행 환경 제공  
**cgroups**: 리소스 사용량 제한 및 모니터링  
**Union FS**: 효율적인 레이어드 파일시스템  
**Copy-on-Write**: 스토리지 효율성  

이러한 기술들을 이해하면 Docker를 더 효과적으로 사용할 수 있고, 문제 발생 시 원인을 파악하고 해결할 수 있습니다.

다음 섹션에서는 이러한 이론을 바탕으로 실제 컨테이너 파일시스템을 다루는 연습을 해보겠습니다!