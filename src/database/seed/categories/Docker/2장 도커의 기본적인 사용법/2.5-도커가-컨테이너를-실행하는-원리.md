---
title: '도커가 컨테이너를 실행하는 원리'
categoryPath:
  - 'Docker'
  - '2장 도커의 기본적인 사용법'
  - '2.5 도커가 컨테이너를 실행하는 원리'
authorNick: '관리자'
createdAt: '2025-08-10'
updateMode: 'upsert'
---

# 도커 내부 동작에 기여하는 요소

Docker는 마법이 아닙니다. 리눅스 커널이 제공하는 기존 기술들을 영리하게 조합하여 컨테이너를 구현합니다. 이번 섹션에서는 Docker의 내부 동작 원리를 이해해보겠습니다.

## Docker의 기본 요소

도커 엔진과의 상호 작용은 도커 CLI를 통해 API를 호출하여 요청을 전달하여 이루어집니다.

- **도커 엔진**(Docker Engine)은 도커의 관리 기능을 맡는 컴포넌트입니다. 로컬 이미지 캐시를 담당하여 새로운 이미지가 필요하면 내려받고, 기존 이미지가 있다면 이를 재사용합니다. 호스트 운영체제와 함께 컨테이너와 가상 네트워크 등 도커 리소스를 만드는 일도 담당하고 항시 동작하는 백그라운드 프로세스입니다.

- **도커 API**는 표준 HTTP 기반 REST API로 도커 엔진에게 기능을 수행하게 합니다.  

- **도커 명령행 인터페이스**(Docker command-line interface)는 도커 API의 클라이언트로 docker명령어를 실제로 호출하는 CLI입니다.

도커 API의 명세는 공개되어 있고, 도커 CLI 외의 그래픽 인터페이스 등의 다른 클라이언트를 사용하여 시각적으로 컨테이너를 관리할 수도 있습니다.

> 도커에서 만든 상업용 도커 API 클라이언트 UCP나 Portainer라는 오픈 소스 클라이언트도 있습니다.

도커 엔진은 containerd라는 컴포넌트를 통해 실제로 컨테이너를 관리하는데 이 컴포넌트는 호스트 운영체제가 제공하는 기능을 통해 가상 환경을 만듭니다. 이때 containerd는 CNCF에서 관리하는 오픈소스 프로젝트이고, **개방형 컨테이너 이니셔티브**(Open Container Initiative, OCI)라는 점을 알아두면 좋습니다.

### 컴포넌트 간의 작동 원리 요약

```
사용자 명령어 → 도커 CLI → 도커 API → 도커 엔진 → 컨테이너 실행
```

예를 들어, `docker container run diamol/ch02-hello-diamol` 명령을 실행하면:

1. **도커 CLI**가 명령어를 받아서 도커 API 호출로 변환
2. **도커 API**가 요청을 도커 엔진에 전달
3. **도커 엔진**이 로컬 이미지 캐시를 확인
4. 이미지가 없으면 도커 허브에서 다운로드
5. 이미지가 있으면 바로 컨테이너로 실행

> 도커 API가 표준 HTTP 기반이기 때문에, 도커 CLI뿐만 아니라 다양한 프로그래밍 언어로 도커를 제어할 수 있습니다. 이것이 도커가 다양한 개발 도구와 CI/CD 파이프라인에 쉽게 통합되는 이유입니다.



## Docker 아키텍처 개요

```
┌─────────────────────────────────────────┐
│           Docker Client (CLI)           │
├─────────────────────────────────────────┤
│           Docker Daemon (dockerd)       │
├─────────────────────────────────────────┤
│    containerd (컨테이너 런타임)         │
├─────────────────────────────────────────┤
│         runc (OCI 런타임)               │
├─────────────────────────────────────────┤
│          Linux Kernel                   │
│   ┌─────────────┬─────────────────────┐  │
│   │ Namespaces  │     cgroups         │  │
│   │             │                     │  │
│   │ UnionFS     │  Security Modules   │  │
│   └─────────────┴─────────────────────┘  │
└─────────────────────────────────────────┘
```

## 1. 네임스페이스 (Namespaces) - 격리의 핵심

네임스페이스는 컨테이너가 "독립된 서버"처럼 보이게 하는 핵심 기술입니다.

### PID 네임스페이스 - 프로세스 격리
```bash
# 호스트에서 프로세스 확인
ps aux | head -5

# 컨테이너에서 프로세스 확인
docker run -it ubuntu bash
ps aux  # PID 1부터 시작하는 독립적인 프로세스 공간
```

### 네트워크 네임스페이스 - 네트워크 격리
```bash
# 호스트의 네트워크 인터페이스
ip addr show

# 컨테이너의 네트워크 인터페이스
docker run -it ubuntu bash
apt update && apt install -y iproute2
ip addr show  # 완전히 다른 네트워크 환경
```

## 2. Control Groups (cgroups) - 리소스 제한

cgroups는 컨테이너가 사용할 수 있는 리소스를 제한하고 모니터링합니다.

### 메모리 제한 실습
```bash
# 512MB 메모리 제한
docker run -it -m 512m ubuntu bash

# 리소스 사용량 실시간 확인
docker stats
```

### CPU 제한 실습
```bash
# CPU 1.5개 코어로 제한
docker run -it --cpus="1.5" ubuntu bash
```

## 3. Union File System - 레이어드 파일시스템

Docker 이미지는 여러 레이어로 구성되며, 실행 시 하나의 통합된 파일시스템으로 보입니다.

### 이미지 레이어 구조
```
┌─────────────────────────────────────┐
│     컨테이너 레이어 (읽기/쓰기)     │  ← 새로운 파일, 수정된 파일
├─────────────────────────────────────┤
│       애플리케이션 레이어           │  ← ADD app.jar /app/
├─────────────────────────────────────┤
│         JDK 레이어                  │  ← FROM openjdk:11
├─────────────────────────────────────┤
│       베이스 OS 레이어              │  ← Ubuntu/Alpine 등
└─────────────────────────────────────┘
```

### 레이어 확인 실습
```bash
# 이미지의 레이어 정보 확인
docker history ubuntu

# 상세한 레이어 정보
docker inspect ubuntu
```

## Docker 실행 과정

### `docker run ubuntu bash` 명령어 실행 시 일어나는 일

1. **이미지 준비**: 로컬에서 이미지 검색, 없으면 레지스트리에서 다운로드
2. **네임스페이스 생성**: PID, Network, Mount, UTS, IPC 네임스페이스 생성  
3. **cgroup 설정**: 리소스 제한 cgroup 생성 및 설정
4. **파일시스템 구성**: Union 파일시스템으로 레이어 마운트
5. **프로세스 실행**: 새로운 네임스페이스에서 bash 프로세스 실행

## 컨테이너와 호스트의 관계

### 프로세스 관점에서 보기
```bash
# 호스트에서 컨테이너 프로세스 확인
docker run -d --name test-container nginx
ps aux | grep nginx

# 컨테이너 내부에서는 PID 1
docker exec test-container ps aux
```

## Docker vs 가상머신

이제 내부 원리를 이해했으니, 왜 Docker가 가상머신보다 빠르고 가벼운지 명확해집니다:

### 가상머신
- 하이퍼바이저가 하드웨어를 에뮬레이션
- 각 VM마다 완전한 게스트 OS 필요
- 메모리, CPU 오버헤드 큼

### Docker 컨테이너  
- 호스트 OS 커널을 공유
- 네임스페이스와 cgroup만으로 격리
- 최소한의 오버헤드

## 요약

Docker는 다음과 같은 Linux 커널 기능들의 조합입니다:

**Namespaces**: 격리된 실행 환경 제공  
**cgroups**: 리소스 사용량 제한 및 모니터링  
**Union FS**: 효율적인 레이어드 파일시스템  
**Copy-on-Write**: 스토리지 효율성  

이러한 기술들을 이해하면 Docker를 더 효과적으로 사용할 수 있고, 문제 발생 시 원인을 파악하고 해결할 수 있습니다.

다음 섹션에서는 이러한 이론을 바탕으로 실제 컨테이너 파일시스템을 다루는 연습을 해보겠습니다!