---
title: '컨테이너란 무엇인가'
categoryPath:
  - 'Docker'
  - '2장 도커의 기본적인 사용법'
  - '2.2 컨테이너란 무엇인가'
authorNick: '관리자'
createdAt: '2025-08-10'
updateMode: 'upsert'
---

# 컨테이너란?

## 컨테이너의 정의

> **컨테이너(Container)**는 애플리케이션과 그 실행에 필요한 모든 환경(라이브러리, 설정파일, 환경변수 등)을 하나의 패키지로 묶어서 격리된 환경에서 실행할 수 있게 하는 기술입니다.

쉽게 풀어 설명해보자면 도커 컨테이너는 **애플리케이션과 실행 환경(라이브러리, 설정, 종속성 등)을 하나로 묶어 격리된 공간에서 실행하는 단위**로서 말 그대로 물건을 담는 컨테이너입니다. 여기에는 애플리케이션에 포함되는 모든 가상의 리소스들을 모아둔 다음에 그것을 이용해서 애플리케이션을 실행하게 됩니다.

컴퓨터(호스트)는 이러한 컨테이너를 여러 개 실행시킬 수 있습니다.  
실행시킨 컨테이너들은 서로 독립적인 환경을 가지지만 컴퓨터(호스트)의 CPU와 메모리, OS 등을 공유합니다.

## 격리와 밀집

위의 구조를 통해 언뜻 서로 충돌할 것 같은 두가지의 특징이 공존할 수 있는 특징을 가질 수 있습니다.

> 밀집 - 컴퓨터에 CPU와 메모리가 허용하는 한 많은 수의 애플리케이션을 실행할 수 있습니다. 

> 격리 - 필요로하는 런타임의 버전이 다르거나, 어느 한 애플리케이션이 과도한 리소스를 독점하는 경우를 막기 위해서 독립된 환경이 필요합니다.

도커는 위의 2가지 특징을 위해서 **가상머신**을 활용해 독립적인 운영체제를 사용합니다.

### 핵심 개념
- **격리(Isolation)**: 다른 애플리케이션과 독립된 환경에서 실행
- **이식성(Portability)**: 어떤 환경에서든 동일하게 실행 가능
- **효율성(Efficiency)**: 가상머신보다 가볍고 빠른 실행

## 가상머신 vs 컨테이너

### 가상머신 (Virtual Machine) 구조
```
┌─────────────────────────────────────────┐
│              애플리케이션                │
├─────────────────────────────────────────┤
│              게스트 OS                   │
├─────────────────────────────────────────┤
│             하이퍼바이저                │
├─────────────────────────────────────────┤
│              호스트 OS                   │
├─────────────────────────────────────────┤
│           물리적 하드웨어               │
└─────────────────────────────────────────┘
```

### 컨테이너 구조
```
┌─────────────────────────────────────────┐
│              애플리케이션                │
├─────────────────────────────────────────┤
│           컨테이너 런타임               │
├─────────────────────────────────────────┤
│              호스트 OS                   │
├─────────────────────────────────────────┤
│           물리적 하드웨어               │
└─────────────────────────────────────────┘
```

### 비교 분석

| 특성 | 가상머신 (VM) | 컨테이너 |
|------|---------------|----------|
| **OS** | 각각 독립적인 OS | 호스트 OS 커널 공유 |
| **크기** | 수 GB ~ 수십 GB | 수 MB ~ 수 GB |
| **시작 시간** | 수 분 | 수 초 |
| **리소스 사용** | 높음 (각 VM마다 OS 필요) | 낮음 (커널 공유) |
| **격리 수준** | 완전 격리 | 프로세스 수준 격리 |
| **보안** | 매우 높음 | 높음 |
| **이식성** | 중간 | 매우 높음 |
| **실행 속도** | 느림 | 빠름 |
| **실행 가능한 앱 수** | 적음 | 많음 (약 5배) |

## 컨테이너의 격리 기술

### Linux Namespace
컨테이너 격리의 핵심 기술로, 다음과 같은 영역을 분리합니다:

#### 1. PID Namespace (프로세스 격리)
```bash
# 호스트에서 실행
docker run -it ubuntu bash

# 컨테이너 내부에서 프로세스 확인
ps aux
# PID 1번부터 시작하는 것을 확인할 수 있음
```

#### 2. Network Namespace (네트워크 격리)
```bash
# 컨테이너별로 독립적인 네트워크 스택
docker run -it ubuntu bash
ifconfig  # 컨테이너만의 네트워크 인터페이스
```

#### 3. Mount Namespace (파일시스템 격리)
```bash
# 컨테이너별로 독립적인 파일시스템
docker run -it ubuntu bash
ls /    # 컨테이너만의 루트 파일시스템
```

#### 4. UTS Namespace (호스트명 격리)
```bash
# 컨테이너별로 독립적인 호스트명
docker run -it --hostname mycontainer ubuntu bash
hostname  # mycontainer 출력
```

### Control Groups (cgroups)
리소스 사용량을 제한하고 모니터링하는 기술:

```bash
# 메모리 제한 컨테이너 실행
docker run -m 512m ubuntu bash

# CPU 제한 컨테이너 실행
docker run --cpus="1.5" ubuntu bash
```

## 컨테이너의 생명주기

### 상태 전환 다이어그램
```
Created → Running → Paused → Running → Stopped → Removed
   ↑         ↓                           ↓         ↓
   └─────────┴───────────────────────────┴─────────┘
```

### 각 상태 설명

#### 1. Created (생성됨)
```bash
docker create --name my-container ubuntu
docker ps -a  # STATUS: Created
```

#### 2. Running (실행 중)
```bash
docker start my-container
docker ps     # STATUS: Up
```

#### 3. Paused (일시 정지)
```bash
docker pause my-container
docker ps -a  # STATUS: Up (Paused)
```

#### 4. Stopped (중지됨)
```bash
docker stop my-container
docker ps -a  # STATUS: Exited
```

#### 5. Removed (제거됨)
```bash
docker rm my-container
# 더 이상 docker ps -a에 나타나지 않음
```

## 컨테이너의 실행 모드

### 1. 포그라운드 모드 (기본값)
```bash
# 터미널에 출력이 직접 표시됨
docker run ubuntu echo "Hello World"
```

### 2. 백그라운드 모드 (-d, --detach)
```bash
# 백그라운드에서 실행되고 컨테이너 ID 반환
docker run -d nginx
```

### 3. 인터랙티브 모드 (-it)
```bash
# 사용자 입력을 받을 수 있는 대화형 모드
docker run -it ubuntu bash
```

## 컨테이너 네트워킹 기초

### 포트 포워딩
```bash
# 호스트의 8080 포트를 컨테이너의 80 포트로 연결
docker run -p 8080:80 nginx

# 여러 포트 연결
docker run -p 3000:3000 -p 8080:80 my-app
```

### 네트워크 모드

#### 1. Bridge 모드 (기본값)
```bash
docker run nginx  # 자동으로 bridge 네트워크 사용
```

#### 2. Host 모드
```bash
# 호스트의 네트워크를 직접 사용
docker run --network host nginx
```

#### 3. None 모드
```bash
# 네트워크 연결 없음
docker run --network none ubuntu
```

## 데이터 지속성

### 볼륨 마운트
```bash
# 호스트 디렉토리를 컨테이너에 마운트
docker run -v /host/path:/container/path ubuntu

# Docker 볼륨 사용
docker volume create my-volume
docker run -v my-volume:/data ubuntu
```

## 실습: 컨테이너 개념 체험하기

### 1. 격리 확인 실습
```bash
# 첫 번째 컨테이너에서 파일 생성
docker run -it --name container1 ubuntu bash
# 컨테이너 내부에서
echo "Hello from container1" > /tmp/test.txt
exit

# 두 번째 컨테이너에서 파일 확인
docker run -it --name container2 ubuntu bash
# 컨테이너 내부에서
cat /tmp/test.txt  # 파일이 없음을 확인
exit
```

### 2. 프로세스 격리 확인
```bash
# 호스트에서 프로세스 확인
ps aux | grep bash

# 컨테이너에서 프로세스 확인
docker run -it ubuntu bash
ps aux  # PID 1부터 시작하는 독립적인 프로세스 공간
```

### 3. 네트워크 격리 확인
```bash
# 호스트 IP 확인
ip addr show

# 컨테이너 IP 확인
docker run -it ubuntu bash
apt update && apt install -y iproute2
ip addr show  # 다른 IP 주소 범위 확인
```

## 컨테이너의 장점과 한계

### 장점
- **빠른 시작**: 커널 공유로 빠른 부팅
- **효율적 리소스 사용**: 메모리와 CPU 효율성
- **이식성**: 환경에 관계없이 동일한 실행
- **확장성**: 쉬운 스케일 아웃
- **DevOps 친화적**: CI/CD 파이프라인 최적화

### 한계
- **보안**: VM보다 상대적으로 낮은 격리 수준
- **OS 종속성**: 호스트 OS 커널 공유
- **지속성**: 컨테이너 삭제 시 데이터 손실 위험
- **복잡성**: 많은 컨테이너 관리의 어려움

## 요약

컨테이너는 **가볍고 빠르며 이식 가능한** 애플리케이션 실행 환경입니다. 가상머신보다 **효율적**이면서도 충분한 격리(서로 충돌하지 않는 독립적인 실행 환경)를 제공하여 현대 소프트웨어 개발과 배포의 핵심 기술이 되었습니다.

다음 섹션에서는 컨테이너를 실제로 조작하고 관리하는 방법을 학습해보겠습니다!