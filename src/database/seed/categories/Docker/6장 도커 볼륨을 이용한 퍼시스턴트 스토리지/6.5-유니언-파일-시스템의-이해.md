---
title: '유니언 파일 시스템: 컨테이너 파일 시스템의 내부 구조'
authorNick: '관리자'
createdAt: '2025-10-15'
updateMode: 'upsert'
---

# 유니언 파일 시스템: 컨테이너 파일 시스템의 내부 구조

## 유니언 파일 시스템이란?

모든 컨테이너는 도커가 **다양한 출처들로부터 모아 만든 단일 가상 디스크**로 구성된 파일 시스템을 갖으며 이를 **유니언 파일 시스템**이라고 한다. 

컨테이너는 이 유니언 파일 시스템을 통해 **물리적 위치가 다른 파일과 디렉터리에 마치 단일 디스크를 사용하듯 접근** 가능하다.

### 핵심 개념

- **투명성**: 컨테이너 내 프로세스는 복잡한 내부 구조를 모르고도 일반적인 파일 시스템처럼 사용
- **계층화**: 여러 레이어가 스택처럼 쌓여서 하나의 파일 시스템을 구성
- **효율성**: 공통 레이어는 공유하고, 변경된 부분만 개별 관리

---

## 유니언 파일 시스템의 구성 요소

사용자는 **여러 출처를 합쳐** 이 디스크를 구성할 수 있다. 각 구성 요소는 서로 다른 목적과 특성을 가진다.

### 1. 기록 가능 레이어 (Writable Layer)

```bash
# 기록 가능 레이어 확인
docker run -d --name test-writable ubuntu:20.04 sleep infinity
docker exec test-writable sh -c "echo 'test data' > /tmp/test.txt"
docker diff test-writable  # 변경된 파일 목록 확인
```

**특징:**
- 비용이 비싼 계산이나 네트워크를 통해 저장해야 하는 데이터의 **캐싱 등 단기 저장**에 적합
- **컨테이너마다 독립적인** 기록 가능 레이어를 갖지만 **컨테이너와 생애주기를 같이함**
- 컨테이너 종료 시 모든 데이터 손실

**활용 사례:**
- 임시 계산 결과 캐싱
- 로그 파일의 버퍼링
- 애플리케이션 런타임 상태

### 2. 로컬 바인드 마운트 (Local Bind Mount)

```bash
# 개발 환경에서 소스 코드 실시간 반영
docker run -d \
  --name dev-container \
  -v $(pwd)/src:/app/src \
  -v $(pwd)/package.json:/app/package.json \
  node:16-alpine \
  npm run dev
```

**특징:**
- **호스트 컴퓨터와 컨테이너 간 데이터를 공유**하기 위해 사용
- 개발자의 로컬 컴퓨터에서 컨테이너로 소스 코드를 전달하기 위해 사용 시 **로컬 컴퓨터의 수정사항이 이미지 빌드 없이 컨테이너에 전달**된다

**활용 사례:**
- 개발 중 소스 코드 Hot Reload
- 로컬 설정 파일 주입
- 디버깅 및 로깅 파일 수집

### 3. 분산 바인드 마운트 (Distributed Bind Mount)

```bash
# NFS를 통한 분산 스토리지 연결
sudo mount -t nfs server.example.com:/shared/data /mnt/nfs-storage

docker run -d \
  --name distributed-app \
  -v /mnt/nfs-storage:/app/shared-data \
  my-distributed-app:latest
```

**특징:**
- **네트워크 스토리지와 컨테이너 간에 데이터를 공유**하기 위해 사용
- **가용성이 높지만** 로컬 디스크와 비교해 지원하지 않는 파일 시스템 기능이 있거나 **성능면에서 차이**가 있을 수 있다
- **읽기 전용**으로 설정 파일을 전달하거나 공유 캐시로 활용할 수 있고, **읽기-쓰기** 가능으로 데이터를 저장해 동일 네트워크상의 모든 컨테이너나 컴퓨터와 데이터를 공유하는데 적합

**활용 사례:**

#### 읽기 전용 활용
```bash
# 공유 설정 파일 배포
docker run -d \
  --name config-consumer \
  -v /mnt/shared-config:/app/config:ro \
  my-app:latest

# 공유 캐시 활용  
docker run -d \
  --name cache-user \
  -v /mnt/redis-cache:/var/cache:ro \
  web-app:latest
```

#### 읽기-쓰기 활용
```bash
# 분산 로그 수집
docker run -d \
  --name log-writer \
  -v /mnt/centralized-logs:/var/log \
  logging-app:latest

# 분산 데이터 처리
docker run -d \
  --name data-processor \
  -v /mnt/shared-workspace:/workspace \
  ml-pipeline:latest
```

### 4. 볼륨 마운트 (Volume Mount)

```bash
# 데이터베이스 데이터 영구 저장
docker volume create postgres-data
docker run -d \
  --name postgres-db \
  -v postgres-data:/var/lib/postgresql/data \
  postgres:13

# 컨테이너 교체 후에도 데이터 유지
docker stop postgres-db && docker rm postgres-db
docker run -d \
  --name postgres-db-new \
  -v postgres-data:/var/lib/postgresql/data \
  postgres:14  # 새 버전으로 업그레이드
```

**특징:**
- **컨테이너와 도커 객체인 볼륨 간에 데이터를 공유**하기 위해 사용
- 애플리케이션이 볼륨에 데이터를 **영구적으로 저장**한다
- **컨테이너를 교체하는 방식으로 업데이트해도 저장된 볼륨 데이터가 유지**된다

**활용 사례:**
- 데이터베이스 데이터 저장
- 사용자 업로드 파일 보관
- 애플리케이션 상태 정보
- 캐시 데이터의 영구 보존

### 5. 이미지 레이어 (Image Layers)

```bash
# 이미지 레이어 구조 확인
docker history ubuntu:20.04
docker inspect ubuntu:20.04 | jq '.[0].RootFS.Layers'

# 멀티 스테이지 빌드로 레이어 최적화
```

```dockerfile
# 이미지 레이어 예제
FROM node:16-alpine AS builder
COPY package*.json ./
RUN npm ci --only=production

FROM node:16-alpine AS runtime
COPY --from=builder node_modules ./node_modules
COPY src ./src
CMD ["node", "src/index.js"]
```

**특징:**
- 컨테이너의 **초기 파일 시스템**을 구성한다
- 레이어는 **적층 구조**를 갖고, 후속 레이어와 이전 레이어의 내용이 서로 충돌하는 경우 **후속 레이어의 내용이 적용**된다
- 레이어는 **읽기 전용**이며 **여러 컨테이너가 공유**한다

**활용 사례:**
- 운영체제 기본 파일
- 애플리케이션 바이너리
- 의존성 라이브러리
- 기본 설정 파일

---

## 유니언 파일 시스템의 동작 방식

### 레이어 우선순위

```bash
# 레이어 스택 (아래에서 위로)
┌─────────────────────┐ ← 컨테이너에서 보이는 최종 파일 시스템
│   기록 가능 레이어    │ ← 가장 높은 우선순위
├─────────────────────┤
│   볼륨 마운트        │
├─────────────────────┤  
│   바인드 마운트      │
├─────────────────────┤
│   이미지 레이어 3    │ 
├─────────────────────┤
│   이미지 레이어 2    │
├─────────────────────┤
│   이미지 레이어 1    │ ← 베이스 이미지 (가장 낮은 우선순위)
└─────────────────────┘
```

### 파일 찾기 순서

1. **기록 가능 레이어**에서 파일 검색
2. 없으면 **마운트된 볼륨/바인드 마운트**에서 검색  
3. 없으면 **상위 이미지 레이어**부터 순차적으로 검색
4. **가장 먼저 찾은 파일**을 반환

```bash
# 파일 우선순위 테스트
docker run -it --rm \
  -v $(pwd)/host-config.txt:/app/config.txt \
  ubuntu:20.04 \
  bash

# 컨테이너 내부에서
echo "container version" > /app/config.txt  # 기록 가능 레이어
cat /app/config.txt  # "container version" 출력 (높은 우선순위)

# 호스트에서 host-config.txt를 변경해도 컨테이너에서는 변경 안 됨
# 이미 기록 가능 레이어에 파일이 있기 때문
```

---

## 성능 및 최적화 고려사항

### 1. 레이어 캐싱 활용

```dockerfile
# ❌ 비효율적 - 소스 코드 변경 시 의존성도 재설치
FROM node:16-alpine
COPY . /app
RUN npm install

# ✅ 효율적 - 의존성은 캐시 활용
FROM node:16-alpine
COPY package*.json /app/
RUN npm ci --only=production
COPY src /app/src
```

### 2. 마운트 성능 비교

```bash
# 성능 테스트 스크립트
test_performance() {
    local mount_type=$1
    local test_name=$2
    
    echo "Testing $test_name..."
    time docker run --rm $mount_type alpine \
        dd if=/dev/zero of=/test/largefile bs=1M count=100
}

# 각 마운트 타입별 성능 테스트
test_performance "-v test-volume:/test" "Volume"
test_performance "-v $(pwd)/test:/test" "Bind Mount"
test_performance "--tmpfs /test" "tmpfs"
```

### 3. 스토리지 드라이버 최적화

```bash
# 현재 스토리지 드라이버 확인
docker info | grep "Storage Driver"

# 스토리지 사용량 확인
docker system df
docker system df -v

# 불필요한 데이터 정리
docker system prune -a --volumes
```

---

## 실무 활용 패턴

### 1. 개발 환경 구성

```yaml
# docker-compose.yml
version: '3.8'
services:
  web:
    build: .
    volumes:
      # 소스 코드 실시간 반영 (로컬 바인드)
      - ./src:/app/src
      # 의존성은 볼륨으로 성능 최적화
      - node_modules:/app/node_modules
      # 로그는 호스트에서 확인 가능하도록
      - ./logs:/var/log/app
    environment:
      - NODE_ENV=development

volumes:
  node_modules:
```

### 2. 운영 환경 구성

```yaml
# docker-compose.prod.yml  
version: '3.8'
services:
  web:
    image: my-app:latest
    volumes:
      # 데이터는 볼륨으로 영구 저장
      - app-data:/app/data
      # 설정은 읽기 전용 바인드
      - /etc/app-config:/app/config:ro
      # 로그는 분산 스토리지로
      - /mnt/centralized-logs:/var/log:rw
    deploy:
      replicas: 3

volumes:
  app-data:
    driver: local
```

### 3. 하이브리드 전략

```bash
# 단계별 마운트 전략
docker run -d \
  --name production-app \
  `# 영구 데이터는 볼륨` \
  -v db-data:/var/lib/mysql \
  -v user-uploads:/app/uploads \
  `# 설정은 읽기 전용 바인드` \
  -v /etc/app/prod.conf:/app/config/app.conf:ro \
  `# 로그는 분산 스토리지` \
  -v /mnt/log-server:/var/log \
  `# 임시 파일은 메모리 기반` \
  --tmpfs /tmp:rw,noexec,nosuid,size=100m \
  my-production-app:latest
```

---

## 문제 해결 및 디버깅

### 1. 파일 시스템 구조 분석

```bash
# 컨테이너의 마운트 구조 확인
docker inspect <컨테이너> | jq '.[0].Mounts'

# 레이어별 파일 시스템 확인
docker exec <컨테이너> df -h
docker exec <컨테이너> mount | column -t

# 특정 파일의 출처 확인
docker exec <컨테이너> ls -la /path/to/file
docker exec <컨테이너> stat /path/to/file
```

### 2. 성능 문제 진단

```bash
# I/O 성능 측정
docker exec <컨테이너> \
  dd if=/dev/zero of=/test-mount/testfile bs=1M count=100 conv=fsync

# 실시간 I/O 모니터링  
docker stats <컨테이너>
docker exec <컨테이너> iostat -x 1

# 파일 시스템별 성능 비교
docker run --rm -v test-vol:/vol-test alpine \
  sh -c "time dd if=/dev/zero of=/vol-test/test bs=1M count=50"
  
docker run --rm -v $(pwd):/bind-test alpine \
  sh -c "time dd if=/dev/zero of=/bind-test/test bs=1M count=50"
```

---

## 정리

유니언 파일 시스템은 도커 컨테이너의 **핵심 기술** 중 하나로, 다음과 같은 **전략적 가치**를 제공한다:

### 주요 이점
- **효율성**: 공통 레이어 공유로 스토리지 사용량 최적화
- **유연성**: 다양한 데이터 소스를 하나의 파일 시스템으로 통합  
- **투명성**: 복잡한 내부 구조를 숨기고 일관된 인터페이스 제공
- **확장성**: 필요에 따라 레이어 추가/제거 가능

### 설계 원칙
1. **목적별 분리**: 각 구성 요소를 용도에 맞게 활용
2. **성능 최적화**: 자주 변경되는 데이터와 정적 데이터 분리
3. **영속성 보장**: 중요한 데이터는 적절한 볼륨 전략 적용
4. **보안 고려**: 최소 권한 원칙으로 마운트 구성

---

## 실습: 유니언 파일 시스템 탐험하기

### 실습 6-15: 레이어 우선순위 확인하기

```bash
# 1. 테스트 환경 설정
mkdir union-fs-test && cd union-fs-test

# 이미지에 기본 파일이 있는 컨테이너 생성
cat > Dockerfile << 'EOF'
FROM alpine:latest
RUN echo "image layer content" > /app/test.txt
RUN echo "image config" > /app/config.txt
WORKDIR /app
CMD ["cat", "/app/test.txt", "/app/config.txt"]
EOF

docker build -t layer-test .

# 2. 호스트 파일 준비
echo "host bind mount content" > host-test.txt
echo "host config content" > host-config.txt

# 3. 볼륨과 바인드 마운트 함께 사용
docker volume create test-volume
echo "volume content" | docker run --rm -i -v test-volume:/data alpine sh -c "cat > /data/volume-test.txt"

# 4. 복합 마운트로 우선순위 테스트
docker run -it --rm \
  -v test-volume:/app/volume-data \
  -v $(pwd)/host-test.txt:/app/test.txt \
  -v $(pwd)/host-config.txt:/app/host-config.txt \
  layer-test \
  sh

# 컨테이너 내에서 확인
cat /app/test.txt  # 바인드 마운트가 이미지 파일을 덮어씀
cat /app/config.txt  # 이미지 레이어의 원본 파일
cat /app/host-config.txt  # 바인드 마운트 파일
ls /app/volume-data/  # 볼륨 마운트 내용
exit
```

### 실습 6-16: Copy-on-Write 메커니즘 관찰

```bash
# 1. 베이스 이미지에서 파일 수정 추적
docker run --name cow-demo ubuntu:20.04 sh -c "
  echo 'Original content' > /tmp/original.txt &&
  echo 'Modified content' >> /etc/hosts &&
  echo 'New file' > /tmp/new.txt
"

# 2. 변경사항 확인
docker diff cow-demo
# 출력 예시:
# A /tmp/original.txt  (Added)
# A /tmp/new.txt       (Added) 
# C /etc/hosts         (Changed)

# 3. 이미지 레이어 vs 기록 가능 레이어
docker commit cow-demo cow-demo-image
docker history cow-demo-image
docker history ubuntu:20.04

# 4. 정리
docker rm cow-demo
```

### 실습 6-17: 성능 비교 벤치마크

```bash
# 1. 성능 테스트 함수 정의
benchmark_storage() {
    local storage_type=$1
    local mount_option=$2
    local test_name=$3
    
    echo "=== $test_name 성능 테스트 ==="
    docker run --rm $mount_option alpine:latest sh -c "
        echo '파일 생성 성능:'
        time sh -c 'for i in \$(seq 1 1000); do echo \"test \$i\" > /test/file\$i.txt; done'
        
        echo '파일 읽기 성능:'
        time sh -c 'for i in \$(seq 1 1000); do cat /test/file\$i.txt > /dev/null; done'
        
        echo '대용량 파일 I/O:'
        time dd if=/dev/zero of=/test/large.bin bs=1M count=10 2>/dev/null
    "
    echo ""
}

# 2. 다양한 스토리지 타입 벤치마크
mkdir benchmark-test && cd benchmark-test

# tmpfs (메모리)
benchmark_storage "tmpfs" "--tmpfs /test:rw,size=100m" "tmpfs (메모리)"

# 도커 볼륨
docker volume create bench-volume
benchmark_storage "volume" "-v bench-volume:/test" "도커 볼륨"

# 바인드 마운트
mkdir bind-mount-test
benchmark_storage "bind" "-v $(pwd)/bind-mount-test:/test" "바인드 마운트"

# 3. 결과 정리
echo "일반적인 성능 순서: tmpfs > 도커볼륨 >= 바인드마운트 > 네트워크스토리지"
```

### 실습 6-18: 복합 마운트 전략 실습

```bash
# 1. 실제 웹 애플리케이션 시나리오 구성
mkdir full-stack-demo && cd full-stack-demo

# 애플리케이션 디렉터리 구조
mkdir -p {src,config,logs,data,cache}

# 샘플 파일들 생성
echo 'console.log("Hello from source!");' > src/app.js
echo 'database_host=localhost' > config/app.conf
echo 'debug=true' > config/dev.conf

# 2. Docker Compose로 복합 마운트 전략
cat > docker-compose.yml << 'EOF'
version: '3.8'
services:
  web-app:
    image: node:16-alpine
    working_dir: /app
    command: ["sh", "-c", "while true; do echo 'App running...'; sleep 30; done"]
    volumes:
      # 소스코드: 개발용 바인드 마운트
      - ./src:/app/src
      - ./config:/app/config:ro
      
      # 데이터: 영구 볼륨
      - app-data:/app/data
      
      # 로그: 호스트 수집용 바인드
      - ./logs:/app/logs
      
      # 캐시: 성능 최적화 볼륨
      - cache-data:/app/cache
      
      # 임시파일: 메모리 기반
    tmpfs:
      - /tmp:rw,size=50m
      - /app/temp:rw,size=100m
    
    environment:
      - NODE_ENV=development

volumes:
  app-data:
  cache-data:
EOF

# 3. 실행 및 마운트 구조 확인
docker-compose up -d
docker-compose exec web-app sh

# 컨테이너 내에서 마운트 구조 분석
df -h  # 파일시스템 타입과 크기 확인
mount | grep -E "(bind|volume|tmpfs)" | sort  # 마운트 정보 확인

# 각 디렉터리별 파일 생성 테스트
echo "source file" > /app/src/test-src.js
echo "data file" > /app/data/test-data.txt  
echo "cache file" > /app/cache/test-cache.txt
echo "log file" > /app/logs/test-log.txt
echo "temp file" > /app/temp/test-temp.txt

exit

# 4. 호스트에서 결과 확인
ls -la src/     # 바인드 마운트: 호스트에서 보임
ls -la logs/    # 바인드 마운트: 호스트에서 보임
ls -la data/    # 볼륨: 호스트에서 직접 안 보임

# 5. 정리
docker-compose down
```

---

## 도커 교과서 핵심 개념

### 유니언 파일 시스템 계층도

```
┌─────────────────────────────────────┐
│         애플리케이션 뷰              │ ← 통합된 단일 파일 시스템으로 보임
├─────────────────────────────────────┤
│  Layer 5: 기록가능레이어 (R/W)       │ ← 컨테이너별 독립적
│  Layer 4: 볼륨마운트 (R/W)          │ ← 영구 데이터
│  Layer 3: 바인드마운트 (R/W or RO)   │ ← 호스트 연결
│  Layer 2: 이미지레이어3 (RO)        │ ← 애플리케이션
│  Layer 1: 이미지레이어2 (RO)        │ ← 런타임
│  Layer 0: 이미지레이어1 (RO)        │ ← 베이스 OS
└─────────────────────────────────────┘
```

### 핵심 개념 총정리

- **유니언 파일 시스템**: 여러 레이어를 하나의 파일 시스템으로 통합하는 기술
- **레이어 우선순위**: 상위 레이어가 하위 레이어를 마스킹하는 원칙
- **Copy-on-Write**: 읽기 전용 레이어 수정 시 기록 가능 레이어로 복사하는 메커니즘
- **마운트 포인트**: 외부 스토리지를 유니언 파일 시스템에 연결하는 지점
- **스토리지 드라이버**: 실제 파일 시스템 구현 (overlay2, aufs, devicemapper 등)

---

## 학습 퀴즈

### 퀴즈 1: 레이어 우선순위
**Q1**: 같은 경로 `/app/config.txt`에 이미지 레이어, 볼륨, 바인드 마운트, 기록 가능 레이어에 각각 파일이 있다면 최종적으로 어느 파일이 보일까?
- A) 이미지 레이어의 파일
- B) 볼륨의 파일
- C) 바인드 마운트의 파일  
- D) 기록 가능 레이어의 파일

<details>
<summary>정답 보기</summary>
<b>정답: D) 기록 가능 레이어의 파일</b><br>
우선순위: 기록 가능 레이어 > 마운트(볼륨/바인드) > 이미지 레이어 순입니다. 가장 상위 레이어에 있는 파일이 최종적으로 보입니다.
</details>

### 퀴즈 2: Copy-on-Write 메커니즘
**Q2**: 이미지 레이어에 있는 `/etc/hosts` 파일을 컨테이너에서 수정했을 때, 실제로 수정되는 곳은?
- A) 원본 이미지 레이어
- B) 새로운 이미지 레이어  
- C) 컨테이너의 기록 가능 레이어
- D) 호스트 파일 시스템

<details>
<summary>정답 보기</summary>
<b>정답: C) 컨테이너의 기록 가능 레이어</b><br>
Copy-on-Write 메커니즘에 의해 파일이 기록 가능 레이어로 복사된 후 수정됩니다. 원본 이미지 레이어는 읽기 전용이므로 변경되지 않습니다.
</details>

### 퀴즈 3: 성능 최적화
**Q3**: 다음 중 가장 빠른 I/O 성능을 보이는 조합은?
- A) 네트워크 NFS + 바인드 마운트
- B) 로컬 SSD + 도커 볼륨
- C) 메모리 기반 tmpfs
- D) 클라우드 블록 스토리지 + 볼륨

<details>
<summary>정답 보기</summary>
<b>정답: C) 메모리 기반 tmpfs</b><br>
성능 순서: tmpfs(메모리) > 로컬 SSD 볼륨 > 로컬 HDD > 네트워크 스토리지<br>
단, tmpfs는 휘발성이므로 임시 데이터용으로만 사용해야 합니다.
</details>

### 퀴즈 4: 실무 시나리오
**Q4**: 웹 애플리케이션에서 다음 데이터들의 최적 스토리지 전략은?

- 소스 코드 (개발환경)
- 데이터베이스 데이터  
- 임시 파일
- 로그 파일

올바른 조합은?
- A) 모두 바인드 마운트
- B) 모두 도커 볼륨
- C) 소스코드(바인드), DB데이터(볼륨), 임시파일(tmpfs), 로그(바인드)
- D) 모두 기록 가능 레이어

<details>
<summary>정답 보기</summary>
<b>정답: C) 용도별 최적 스토리지 전략</b><br>
- 소스 코드: 개발 시 실시간 반영을 위해 바인드 마운트<br>
- DB 데이터: 영속성을 위해 도커 볼륨<br>
- 임시 파일: 성능을 위해 tmpfs (메모리)<br>
- 로그 파일: 호스트에서 접근을 위해 바인드 마운트
</details>

### 퀴즈 5: 고급 개념
**Q5**: 다음 중 유니언 파일 시스템의 장점이 아닌 것은?
- A) 이미지 레이어 공유로 스토리지 효율성 증대
- B) 각 컨테이너마다 독립된 파일 시스템 제공
- C) 모든 파일 시스템 기능의 완벽 지원
- D) Copy-on-Write로 메모리 사용량 최적화

<details>
<summary>정답 보기</summary>
<b>정답: C) 모든 파일 시스템 기능의 완벽 지원</b><br>
유니언 파일 시스템은 하드링크, 특정 권한 속성 등 일부 고급 파일 시스템 기능을 제한적으로 지원합니다. 특히 분산 스토리지와 결합될 때 더 많은 제약이 있을 수 있습니다.
</details>

---

## 핵심 메시지

**"5개의 레이어, 하나의 파일 시스템"** - 도커 교과서가 강조하는 유니언 파일 시스템의 본질입니다!

### 실무 설계 가이드
1. **임시 데이터**: 기록 가능 레이어 또는 tmpfs 활용
2. **개발 코드**: 바인드 마운트로 실시간 반영
3. **영구 데이터**: 볼륨으로 안전한 보관
4. **설정 파일**: 읽기 전용 바인드 마운트
5. **분산 데이터**: 네트워크 스토리지 + 볼륨 조합

### 성능 최적화 원칙
- **자주 변경**: 상위 레이어 (기록 가능, 바인드)
- **안정적 데이터**: 중간 레이어 (볼륨)  
- **기본 시스템**: 하위 레이어 (이미지)
- **임시 처리**: 메모리 기반 (tmpfs)

**유니언 파일 시스템의 구조를 이해하면** 컨테이너의 스토리지 요구사항에 맞는 최적의 솔루션을 설계할 수 있으며, 성능과 안정성을 동시에 확보할 수 있습니다!