{
  "name": "Docker",
  "children": [
    {
      "name": "1장 시작하기 전에",
      "children": [
        { "name": "1.1 컨테이너가 IT 세상을 점령한 이유" },
        { "name": "1.2 대상 독자" },
        { "name": "1.3 실습 환경 구축하기" },
        { "name": "1.4 바로 활용하기" }
      ]
    },
    {
      "name": "2장 도커의 기본적인 사용법",
      "children": [
        { "name": "2.1 컨테이너로 Hello World 실행하기" },
        { "name": "2.2 컨테이너란 무엇인가?" },
        { "name": "2.3 컨테이너를 원격 컴퓨터처럼 사용하기" },
        { "name": "2.4 컨테이너를 사용해 웹 사이트 호스팅하기" },
        { "name": "2.5 도커가 컨테이너를 실행하는 원리" },
        { "name": "2.6 연습 문제: 컨테이너 파일 시스템 다루기" }
      ]
    },
    {
      "name": "3장 도커 이미지 만들기",
      "children": [
        { "name": "3.1 도커 허브에 공유된 이미지 사용하기" },
        { "name": "3.2 Dockerfile 작성하기" },
        { "name": "3.3 컨테이너 이미지 빌드하기" },
        { "name": "3.4 도커 이미지와 이미지 레이어 이해하기" },
        { "name": "3.5 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화" },
        { "name": "3.6 연습 문제" }
      ]
    },
    {
      "name": "4장 애플리케이션 소스 코드에서 도커 이미지까지",
      "children": [
        { "name": "4.1 Dockerfile이 있는데 빌드 서버가 필요할까" },
        { "name": "4.2 애플리케이션 빌드 실전 예제: 자바 소스 코드" },
        { "name": "4.3 애플리케이션 빌드 실전 예제: Node.js 소스 코드" },
        { "name": "4.4 애플리케이션 빌드 실전 예제: Go 소스 코드" },
        { "name": "4.5 멀티 스테이지 Dockerfile 스크립트 이해하기" },
        { "name": "4.6 연습 문제" }
      ]
    },
    {
      "name": "5장 도커 허브 등 레지스트리에 이미지 공유하기",
      "children": [
        { "name": "5.1 레지스트리, 리포지터리, 이미지 태그 다루기" },
        { "name": "5.2 도커 허브에 직접 빌드한 이미지 푸시하기" },
        { "name": "5.3 나만의 도커 레지스트리 운영하기" },
        { "name": "5.4 이미지 태그를 효율적으로 사용하기" },
        { "name": "5.5 공식 이미지에서 골든 이미지로 전환하기" },
        { "name": "5.6 연습 문제" }
      ]
    },
    {
      "name": "6장 도커 볼륨을 이용한 퍼시스턴트 스토리지",
      "children": [
        { "name": "6.1 컨테이너 속 데이터가 사라지는 이유와 해결 방향" },
        { "name": "6.2 도커 볼륨을 활용한 영구 데이터 저장" },
        { "name": "6.3 바인드 마운트로 호스트와 컨테이너 직접 연결하기" },
        { "name": "6.4 파일 시스템 마운트의 한계점과 주의사항" },
        { "name": "6.5 유니언 파일 시스템의 이해" }
      ]
    },
    {
      "name": "7장 도커 컴포즈로 분산 애플리케이션 실행하기",
      "children": [
        { "name": "7.1 도커 컴포즈 파일의 구조" },
        { "name": "7.2 도커 컴포즈를 사용해 여러 컨테이너로 구성된 애플리케이션 실행하기" },
        { "name": "7.3 도커 컨테이너 간의 통신" },
        { "name": "7.4 도커 컴포즈로 애플리케이션 설정값 지정하기" },
        { "name": "7.5 도커 컴포즈도 만능은 아니다" },
        { "name": "7.6 연습 문제" }
      ]
    },
    {
      "name": "8장 헬스 체크와 디펜던시 체크로 애플리케이션의 신뢰성 확보하기",
      "children": [
        { "name": "8.1 헬스 체크를 지원하는 도커 이미지 빌드하기" },
        { "name": "8.2 디펜던시 체크가 적용된 컨테이너 실행하기" },
        { "name": "8.3 애플리케이션 체크를 위한 커스텀 유틸리티 만들기" }
      ]
    },
    {
      "name": "9장 컨테이너 모니터링으로 투명성 있는 애플리케이션 만들기",
      "children": [
        { "name": "9.1 컨테이너화된 애플리케이션에서 사용되는 모니터링 기술 스택" },
        { "name": "9.2 측정값 수집을 맡을 프로메테우스 컨테이너 실행하기" }
      ]
    },
    {
      "name": "10장 도커 컴포즈를 이용한 여러 환경 구성",
      "children": [
        { "name": "10.1 도커 컴포즈로 여러 개의 애플리케이션 배포하기" },
        { "name": "10.2 환경 변수와 비밀값을 이용해 설정 주입하기" },
        { "name": "10.3 도커를 이용한 설정 워크플로 이해하기" }
      ]
    },
    {
      "name": "11장 도커와 도커 컴포즈를 이용한 애플리케이션 빌드 및 테스트",
      "children": [
        { "name": "11.1 도커를 이용한 지속적 통합 절차" },
        { "name": "11.2 도커를 이용한 빌드 인프라스트럭처 구축하기" },
        { "name": "11.3 도커 컴포즈를 이용한 빌드 설정" },
        { "name": "11.4 도커 외의 의존 모듈이 불필요한 CI 작업 만들기" },
        { "name": "11.5 CI 파이프라인에 관계된 컨테이너" },
        { "name": "11.6 연습 문제" }
      ]
    },
    {
      "name": "12장 컨테이너 오케스트레이션: 도커 스웜과 쿠버네티스",
      "children": [
        { "name": "12.1 컨테이너 오케스트레이션 도구란?" },
        { "name": "12.2 도커 스웜으로 클러스터 만들기" },
        { "name": "12.3 도커 스웜 서비스로 애플리케이션 실행하기" },
        { "name": "12.4 클러스터 환경에서 네트워크 트래픽 관리하기" },
        { "name": "12.5 도커 스웜과 쿠버네티스 중 무엇을 사용할까?" },
        { "name": "12.6 연습 문제" }
      ]
    },
    {
      "name": "13장 도커 스웜 스택으로 분산 애플리케이션 배포하기",
      "children": [
        { "name": "13.1 도커 컴포즈를 사용한 운영 환경" },
        { "name": "13.2 컨피그 객체를 이용한 설정값 관리" },
        { "name": "13.3 비밀값을 이용한 대외비 설정 정보 관리하기" },
        { "name": "13.4 스웜에서 볼륨 사용하기" },
        { "name": "13.5 클러스터는 스택을 어떻게 관리하는가?" },
        { "name": "13.6 연습 문제" }
      ]
    },
    {
      "name": "14장 업그레이드와 롤백을 이용한 업데이트 자동화",
      "children": [
        { "name": "14.1 도커를 사용한 애플리케이션 업그레이드 프로세스" },
        { "name": "14.2 운영 환경을 위한 롤링 업데이트 설정하기" },
        { "name": "14.3 서비스 롤백 설정하기" },
        { "name": "14.4 클러스터의 중단 시간" },
        { "name": "14.5 스웜 클러스터의 고가용성" },
        { "name": "14.6 연습 문제" }
      ]
    },
    {
      "name": "15장 보안 원격 접근 및 CI/CD를 위한 도커 설정",
      "children": [
        { "name": "15.1 도커 API의 엔드포인트 형태" },
        { "name": "15.2 보안 원격 접근을 위한 도커 엔진 설정" },
        { "name": "15.3 도커 컨텍스트를 사용해 원격 엔진에서 작업하기" },
        { "name": "15.4 지속적 통합 파이프라인에 지속적 배포 추가하기" },
        { "name": "15.5 도커 리소스의 접근 모델" },
        { "name": "15.6 연습 문제" }
      ]
    },
    {
      "name": "16장 어디서든 실행할 수 있는 도커 이미지 만들기: 리눅스, 윈도, 인텔, ARM",
      "children": [
        { "name": "16.1 다중 아키텍처 이미지가 중요한 이유" },
        { "name": "16.2 다중 아키텍처 이미지를 만들기 위한 Dockerfile 스크립트" },
        { "name": "16.3 다중 아키텍처 이미지를 레지스트리에 푸시하기" },
        { "name": "16.4 도커 Buildx를 사용해 다중 아키텍처 이미지 빌드하기" },
        { "name": "16.5 개발 로드맵과 다중 아키텍처 이미지" },
        { "name": "16.6 연습 문제" }
      ]
    },
    {
      "name": "17장 도커 이미지 최적화하기: 보안, 용량, 속도",
      "children": [
        { "name": "17.1 도커 이미지를 최적화하는 방법" },
        { "name": "17.2 좋은 기반 이미지를 고르는 법" },
        { "name": "17.3 이미지 레이어 수와 이미지 크기는 최소한으로" },
        { "name": "17.4 멀티 스테이지 빌드를 한 단계 업그레이드하기" },
        { "name": "17.5 최적화가 중요한 이유" },
        { "name": "17.6 연습 문제" }
      ]
    },
    {
      "name": "18장 컨테이너의 애플리케이션 설정 관리",
      "children": [
        { "name": "18.1 다단 애플리케이션 설정" },
        { "name": "18.2 환경별 설정 패키징하기" },
        { "name": "18.3 런타임에서 설정 읽어 들이기" },
        { "name": "18.4 레거시 애플리케이션에 설정 전략 적용하기" },
        { "name": "18.5 유연한 설정 모델의 이점" },
        { "name": "18.6 연습 문제" }
      ]
    },
    {
      "name": "19장 도커를 이용한 로그 생성 및 관리",
      "children": [
        { "name": "19.1 표준 에러 스트림과 표준 출력 스트림" },
        { "name": "19.2 다른 곳으로 출력된 로그를 stdout 스트림에 전달하기" },
        { "name": "19.3 컨테이너 로그 수집 및 포워딩하기" },
        { "name": "19.4 로그 출력 및 로그 컬렉션 관리하기" },
        { "name": "19.5 컨테이너의 로깅 모델" },
        { "name": "19.6 연습 문제" }
      ]
    },
    {
      "name": "20장 리버스 프록시를 이용해 컨테이너 HTTP 트래픽 제어하기",
      "children": [
        { "name": "20.1 리버스 프록시란?" },
        { "name": "20.2 리버스 프록시의 라우팅과 SSL 적용하기" },
        { "name": "20.3 프록시를 이용한 성능 및 신뢰성 개선" },
        { "name": "20.4 클라우드 네이티브 리버스 프록시" },
        { "name": "20.5 리버스 프록시를 활용한 패턴의 이해" },
        { "name": "20.6 연습 문제" }
      ]
    },
    {
      "name": "21장 메시지 큐를 이용한 비동기 통신",
      "children": [
        { "name": "21.1 비동기 메시징이란?" },
        { "name": "21.2 클라우드 네이티브 메시지 큐 사용하기" },
        { "name": "21.3 메시지 수신 및 처리" },
        { "name": "21.4 메시지 핸들러로 기능 추가하기" },
        { "name": "21.5 비동기 메시징 패턴 이해하기" },
        { "name": "21.6 연습 문제" }
      ]
    },
    {
      "name": "22장 끝없는 정진",
      "children": [
        { "name": "22.1 도커를 이용한 개념 검증" },
        { "name": "22.2 소속 조직에서 도커의 유용함을 입증하라" },
        { "name": "22.3 운영 환경으로 가는 길" },
        { "name": "22.4 도커 커뮤니티 소개" }
      ]
    }
  ]
}
